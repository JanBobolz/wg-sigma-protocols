\documentclass[runningheads]{llncs}

\newif\ifanonymous
\anonymoustrue

\usepackage{adjustbox}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage[advantage,
            adversary,
            asymptotics,
            complexity,
            ff,
            lambda,
            mm,
            operators,
            primitives,
            probability,
            sets]{cryptocode}
\usepackage{enumitem}
\usepackage{mathtools}
\usepackage[disable]{todonotes}

\usepackage[%dvips,
    pdftex,
    pdftitle={Proposal: Sigma-protocols},
    pdfauthor={Stephan Krenn and Michele Orr√π}, pdfpagelabels=true, %linktocpage=true,     backref=page,
    bookmarks,bookmarksopen,bookmarksdepth=3,
    breaklinks,colorlinks,citecolor=blue,linkcolor=blue,urlcolor=blue
   ]{hyperref}
\usepackage[capitalize,nameinlink,sort]{cleveref}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{pifont}


\input{macros}


\begin{document}

\title{Proposal: $\Sigma$-protocols}
%
\titlerunning{Proposal: $\Sigma$-protocols}

\ifanonymous
\author{}
\institute{}
\else
\author{Stephan Krenn\inst{1} \and
        Michele Orr\`u\inst{2}}
\authorrunning{S. Krenn and M. Orr\`u}
\institute{AIT Austrian Institute of Technology, Vienna, Austria \and
           University of California, Berkeley, United States}

\fi
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
  Over the last years, zero-knowledge proofs of knowledge based on $\Sigma$-protocols have found numerous applications.
  However, up to date there is still a lack of standardization of such protocols, potentially hindering even broader deployment, and increasing the risk of insecure implementations. 
  This document proposes a standardization effort for non-interactive $\Sigma$-protocols in prime order groups, allowing for AND and OR composition, either in compact (challenge, response) or batchable form (commitment, response). 
  The document provides the necessary formal background, specifies the protocols in full details, provides examples, suggests concrete instantiations (e.g., regarding the selection of elliptic curves or hash functions), and provides guidelines to ease the secure and compatible implementation of $\Sigma$-protocols.

\keywords{Zero-knowledge proofs of knowledge  \and $\Sigma$-protocols.}
\end{abstract}

\section{Introduction}

Zero-knowledge~\cite{GolMicRac89} proofs of knowledge~\cite{C:BelGol92} allow a prover to convince a verifier that he knows a secret piece of information, without revealing anything else that what is already revealed by the claim itself.
Many practically relevant proof goals can be realized using so-called $\Sigma$-protocols, or their non-interactive counterparts, which can be proven secure in the random oracle model without the need for a common reference string.
Introduced by Schnorr~\cite{JC:Schnorr91} over 30 years ago, they are now widely used  in practice because of their simplicity, maturity, and versatility.

$\Sigma$-protocols played an essential component in the building of a number of cryptographic
constructions,
such as anonymous credentials~\cite{CCS:ChaMeiZav14}, password-authenticated key exchange~\cite{jpake}, signatures~\cite{C:Schnorr89},
ring signatures~\cite{borromeansig}, blind signatures~\cite{CCS:PoiSte97}, multi signatures~\cite{CCS:NRSW20}, threshold signatures~\cite{EPRINT:KomGol20} and more.
Lueks et al.~\cite{zksk}, reported that solely in the years 2018-2019 editions of PETS, ACM CCS, WPES, NDSS,
7 publications use  $\Sigma$-protocols.
Yet, there is no standardized way of implementing them and as a result a lot of implementations have shared common pitfalls (cf.\ \cref{sec:motivation}).

We make a first attempt at the standardization of $\Sigma$-protocols by proposing a framework for proving statements about discrete logarithms and related relations in prime-order groups, targeting specifically groups in elliptic curves. To the best of our knowledge, currently deployed and implemented $\Sigma$-protocols mostly rely on the following sub-set of features:

\begin{itemize}
  \item \textbf{Discrete logarithm equality, Diffie-Hellman triples.}
  Proving discrete logarithm equality, DDH triples, or more in general linear relations among secrets is an essential task for some protocols. This is the case of some VOPRFs such as~\cite{AC:JarKiaKra14},
  which is currently in process of standardization~\cite{cfrg-voprf}, and internally employs $\Sigma$-protocols to prove discrete logarithm equality.
  DLEQ proofs are also being used by Privacy Pass~\cite{PoPETS:DGSTV18}, a lightweight anonymous credential that has been implemented and deployed at scale by Cloudflare, Brave
  Browser, and others.
  There are also other works, published in recent academic conferences, that rely on this type of relations: Cryptography for \#metoo~\cite{PoPETS:KuyKraRab19}; Solidus~\cite{CCS:CZJKJS17}; ClaimChain~\cite{ClaimChain}.
  \item \textbf{Knowledge of plaintexts, openings of commitments}
  The so-called AND-composition of dlog relations has been used over a number of protocols,
  including in Algebraic MACs~\cite{CCS:ChaMeiZav14}.
  Algebraic MACs are now used in Signal's group chats~\cite{CCS:ChaPerZav20} and deployed to millions of users.
  \item \textbf{Proving knowledge of one among multiple discrete logarithms.}
  OR-composition of $\Sigma$-protocols
  has been used for range proofs~\cite{borromeansig}, and ring signatures: it enables for private transactions in CryptoNote (Monero)~\cite{monero}.
  OR-composition is also used in other tools such as Mesh~\cite{PoPETS:AlTGon19}.
  %\item Coconut~\cite{NDSS:SABMD19} with threshold Issuance Selective Disclosure Credentials with Applications to Distributed Ledgers;
  % \item Anonymous Credentials Light~\cite{CCS:BalLys13}
\end{itemize}


All these protocols can be implemented using the API that we propose in \cref{sec:composition}.
A request for standardization has also been posted on the \href{https://community.zkproof.org/t/standardizing-sigma-protocols/471/}{zk-proof community} and received a fair amount of interest.

% \subsection{Related Work}

\section{Background and Motivation}
\label{sec:motivation}
So far, there has been little literature meant to help cryptography engineers implement correctly $\Sigma$-protocols for arbitrary statements about discrete logs.
Despite Schnorr signatures and zero-knowledge proofs have already been standardized (respectively in \cite{rfc8032} and \cite{rfc8235}), there is still no formal, established way to implement  $\Sigma$-protocols and their composition.
 Additionally, as academic papers focus on proving the security of  $\Sigma$-protocols in generic cyclic groups, the implementation details are often times overlooked, and, as a result, a lot of insecure implementations have been published in the past. To name a few, well-known pitfalls that have led to insecure implementations:
\begin{itemize}
  \item \textbf{Implementation over non-prime order groups led to small subgroup attacks}. The cyclic group where proofs are being implemented must be carefully selected. Implementing $\Sigma$-protocol over Weierstrass curves is appealing for its performances and straight-line scalar multiplication formul\ae.
   However, the presence of a small cofactor could be fatal for security.
In 2017, Monero~\cite{monero-fail} disclosed a vulnerability in Cryptonote-based e-currencies that would allow double-spending
due to the use of \verb|curve25519|~\cite{PKC:Bernstein06} in place of a prime-order curve.
%\href{https://tools.ietf.org/html/rfc2785#ref-LAW}{RFC2785}, that already provides solutions for avoiding small subgroup attacks)
  \item \textbf{Leakage, partial leakage, or reuse of the commitment is fatal.}
  The first message in a  $\Sigma$-protocol, sometimes called \emph{nonce} or \emph{commitment}, must be uniformly distributed in order to preserve zero-knowledge. Re-use of the same nonce~\cite{CCS:ANTTY20}, or partial leakage allows for the complete recovery of the witness to be proven.
  A blatant instance of this mistake was uncovered in 2010, by the hacker group \texttt{fail0verflow} (for EC-DSA). They showed how SONY was reusing the same nonce for digitally signing PlayStation 3 games\footnote{\url{https://media.ccc.de/v/27c3-4087-en-console_hacking_2010}}.  The member could exploit this to calculate the private key, and create valid signatures.

  \item \textbf{A weak implementation of Fiat--Shamir heuristic compromises adaptive security.} The second message in a  $\Sigma$-protocol, sometimes called \emph{challenge}, if computed non-interactively must include not only the commitment, but the full statement and the group description.

  If the random oracle is invoked solely on the commitment (c.f.\ weak Fiat-Shamir transformation~\cite[Def.\ 2]{AC:BerPerWar12}), then it is possible, given a proof $\pi$, to produce another proof $\pi'$ for a different statement without knowing its witness.
  For instance, if the group generator $G$ is not included in the hash input, then it is possible to prove statements under a different generator $\alpha G$, for any $\alpha \in \ZZ_p$.
  Similarly, if $X \in \GG$, part of the statement, is not included in the query to the random oracle, it is possible to compute proofs for $\beta X$, for any $\beta \in \ZZ_p$.
  Mistakes of this class were uncovered by Bernhard et al.~\cite{AC:BerPerWar12}, by Haines et al.~\cite{SP:HLPT20}, and by Cortier et al.~\cite{cortier2020}.
  They all showed how some voting systems, respectively Helios,  Scytl-SwissPost, and Belenios, incorrectly
  implemented the Fiat--Shamir heuristic, allowing for tampering of votes.

\end{itemize}
We stress that is not straightforward to implement $\Sigma$-protocols given the currently available engineering literature.
%Despite Schnorr proofs have been standardized as zero-knowledge proofs (c.f.\ \href{https://tools.ietf.org/html/rfc8235}{RFC8235}) and signatures (c.f.\ ed25519 in \href{https://tools.ietf.org/html/rfc8032}{RFC8032}),
For instance,
the current standardized \verb|ed25519| cannot be immediately adapted to a zero-knowledge proof in a secure way,
because of its malleability~\cite[p. 7]{JCEng:BDLSY12},  and the different behavior on the batched and compressed
form\footnote{\url{https://hdevalence.ca/blog/2020-10-04-its-25519am}}.

Hence, we hereby propose the creation of a working group that includes both recent cryptanalytic insights as well as the
(partial) solutions described in other known standardization documents.
\section{Notation and Terminology}
\label{sec:notation}

For the purpose of this document, the following notation will be used:

\begin{tabular}{r@{\hspace{1em}}p{9cm}}
    $\secpar$ & main security parameter\\
    $a, x, w, \dots$ & elements $\!\!\!\mod p$ \\
    $\GG = \langle G \rangle$ & cyclic group of prime order $p$ generated by $G$\\
    $G, H, Y, \dots$ & group elements in $\GG$ \\
    $\prover,\verifier,\dots$ & potentially randomized algorithms\\
    $x \defeq 1$ & assignment of the value 1 to $x$\\
    $x\sample\someset$ & assignment of a uniformly random element in $\someset$ to $x$\\
    $x\gets\alg(in)$ & assignment of the output of a randomized algorithm $\alg$ on input $in$ to $x$\\
    $\relation$ & binary relation\\
    $\lang(\relation)$ & language induced by a binary relation $\relation$\\
    % i.e., $\lang(\relation)=\{y\in\{0,1\}^*:\exists w$ such that $(y,w)\in\relation\}$.\\
    $|y|$ & bitlength of a string\\
    $\NN,\ZZ$ & non-negative natural numbers and integers, respectively
\end{tabular}

\subsection{Formal Definitions}
  In the following we provide the formal definitions required for the remainder of this document.

\begin{definition}
  For two groups $\GG_1,\GG_2$, a function $\varphi:\GG_1\to\GG_2:x\mapsto\varphi(x)$ is a \emph{(group) homomorphism}, if and only if for all $a,b\in\GG_1$ it holds that $\varphi(a+b)=\varphi(a)+\varphi(b)$.
\end{definition}

\subsubsection{$\Sigma$-Protocols}~\\

In the following, we formally describe the class of $\Sigma$-protocols, which covers all protocols considered in the remainder of this document.
 For an in-depth discussion of the underlying theory we refer to Cramer~\cite{cramer97}.
\begin{definition}\label{def:sigma}
  Let $\relation$ be a binary relation and let $(Y,w)\in\relation$.
  An interactive two-party protocol specified by algorithms $(\prover_1,\prover_2,\verifier)$ is called a \emph{$\Sigma$-protocol} for $\relation$ with challenge set $\CS$, public input $Y$, and private input $w$, if and only if it satisfies the following conditions:
  \begin{description}
    \item[\bf 3-move form:]
      The protocol is of the following form (cf. also~\cref{fig:generic}):
      \begin{itemize}
        \item
          The prover computes $(\commitment,\st) \gets \prover_1(\witness,\statement)$ and sends $T$ to the verifier, while keeping $\st$ secret.
        \item
          The verifier draws $c\sample\CS$ and returns it to the prover.
        \item
          The prover computes $s\gets\prover_2(\witness,\statement,\challenge,\st)$ and sends $s$ to the verifier.
        \item
          The verifier accepts the protocol run, if and only if $\verifier(Y, T,\challenge,s)=\accept$, otherwise it rejects.
      \end{itemize}
      The protocol transcript $(\commitment,\challenge,s)$ is called \emph{accepting} if the verifier accepts the protocol run.
    \item[\bf Completeness:]
      If $(Y,w)\in\relation$, then the verifier always outputs $\accept$.
    \item[\bf $k$-special soundness:]
      There exists an efficient algorithm $\ext$ which, given $Y$ and $k$ accepting protocol transcripts $(\commitment,c_i,s_i)$ for $i=1,\dots,k$ for public input $Y$ with the same first message but pairwise distinct challenges (i.e., $c_i\ne c_j$ for $i\ne j$), returns $w$ such that $(Y,w)\in\relation$.
      \item[\bf Special honest-verifier zero-knowledge:]
      There exists an efficient algorithm $\simulator$, which on input $Y$ and a challenge $c\in\CS$, outputs transcripts of the form $(\commitment,\challenge,s)$ whose distribution is indistinguishable from accepting protocol transcripts generated by real protocol runs on public input $y$ and with challenge $c$.
  \end{description}
    \begin{protocol}{Generic flow of a $\Sigma$-protocol.\\[-2.25em]}{fig:generic}{t}
      \begin{tabular}{@{}l@{\hspace{-2em}}c@{\hspace{-2em}}r@{}}
        $\prover(\witness,Y,\relation)$ & & $\verifier(Y,\relation)$  \\
        \hline  \\
      % -----------------------------P1-------------------------------
        $(\commitment,\st) \gets \prover_1(\witness,\statement)$\\
        & $\sendr{T}{100}$ \\[2 ex]
      % -----------------------------CHALLENGE-------------------------------
        & & $c \sample \CS$ \\
        & $\sendl{c}{100}$ & \\[2 ex]
      % -----------------------------P2-------------------------------
        $ s \gets \prover_2(\witness,\statement,\commitment,\challenge,\st)$\\
        & $\sendr{s}{100}$ \\[2 ex]
      % -----------------------------V-------------------------------
        & & $\accept/\reject \gets \verifier(\statement,\commitment,\challenge,s)$ \\
      \end{tabular}
    \end{protocol}
\end{definition}
Note that $\Sigma$-protocols were originally introduced for the case $k=2$ only.
However, we use the above generalized definition as certain practically relevant optimization techniques require $k>2$.

A $\Sigma$-protocol is said to have \emph{unpredictable commitments} if the probability of generating a collision in the first message is negligible, i.e., if there is a negligible function $\negl$ such that for all $(Y,w)\in\relation$ it holds that:
\[
  \prob{T'=T'' : T'\gets\prover_1(\witness,\statement), T''\gets\prover_1(\witness,\statement)} \leq \negl\,.
\]

A $\Sigma$-protocol is said to have \emph{perfectly unique responses} if it is infeasible to find two distinct valid responses for a given first message and fixed challenge, i.e., there exist no values $\statement,\commitment,\challenge,s',s''$ with $s'\ne s''$ such that $\verifier(\statement,\commitment,\challenge,s')=\verifier(\statement,\commitment,\challenge,s'')=\accept$.
In case that it is only computationally infeasible (also for a quantum attacker) to find two responses for given $\statement, \commitment,\challenge$, the protocol is said to have \emph{(computationally) unique responses}.


\subsubsection{Proof Systems and Proofs of Knowledge}~\\

The concept of interactive proofs of knowledge was first mentioned by Goldreich et al.~\cite{STOC:GolMicRac85}, and then refined by Feige et al.~\cite{STOC:FeiFiaSha87}.
The definitions in the following are due to Bellare and Goldreich~\cite{C:BelGol92}.

Intuitively, a proof system is sound, if it is not possible to make the verifier accept for statements for which no valid witness exists, cf. also~\cite[1.6.2]{zkproof-reference}.
\begin{definition}\label{def:soundness}
  Let $\relation$ be a binary relation, $\sigma:\NN\to[0,1]$, and let $\prover$ and $\verifier$ specify a probabilistic interactive protocol, where at least $\verifier$ is polynomial time.
  The protocol is called \emph{sound} with \emph{soundness error} $\sigma$, if for every $Y\notin\lang(\relation)$,
  %every $w\in\bin^*$,
  and every interactive algorithm $\prover^*$, the probability that $\prover^*$ makes $\verifier$ output $\accept$ on common input $Y$ is bounded above by $\sigma(|Y|)$.
\end{definition}

Informally, an interactive protocol is a proof of knowledge, if every party that is able to make the verifier accept with sufficiently high probability needs to know a valid witness or would be able to compute such a witness, cf. also~\cite[1.6.3]{zkproof-reference}.
\begin{definition}\label{def:pok}
  Let $\relation$ be a binary relation, $\kappa:\NN\to[0,1]$ and let $\prover$ and $\verifier$ specify a probabilistic interactive protocol, where at least $\verifier$ is polynomial time.
  The protocol is then called a \emph{proof of knowledge} for $\relation$ with \emph{knowledge error} $\kappa$, if the following conditions are satisfied:
  \begin{description}
    \item[Completeness:]
      If $(Y,w)\in\relation$, then the verifier (on input $Y$) always outputs $\accept$ in an interaction with the prover (on input $(Y,w)$).
    \item[Knowledge soundness:]
      There exists a probabilistic algorithm $\ext$ (the \emph{knowledge extractor}) and a polynomial $\poly$ such that the following holds:
      for every interactive algorithm $\prover^*$ and every $Y\in\lang(\relation)$, let $\varepsilon(Y,\prover^*)$ be the probability that $\prover^*$ makes $\verifier$ output $\accept$ on common input $Y$.
      If $\varepsilon(Y,\prover^*)>\kappa(|Y|)$, then $\ext$, having rewindable black-box access to $\prover^*$, outputs $w'$ satisfying $(Y,w')\in\relation$ in an expected number of steps bounded by $\frac{\poly[|Y|]}{\varepsilon(Y,\prover^*)-\kappa(|Y|)}$.
  \end{description}
\end{definition}

Informally, a proof system is simulation sound, if no adversary is able to generate wrong proofs, even if it can request arbitrary fake proofs from a simulator.
The following definition is taken from Unruh~\cite{AC:Unruh17}.
\begin{definition}[Informal]
  A non-interactive proof system $(\prover,\verifier)$ is \emph{strongly simulation sound} with respect to a simulator $\simulator$, if and only if for any (potentially quantum) polynomial-time algorithm $\adv$, the following probability is negligible:
  $$
    \Pr\left[\verifier^{H'}(\statement,\pi)=\accept\land\statement\notin\lang(\relation)\land(\statement,\pi)\notin\mathsf{S} : (\statement,\pi)\gets\adv^{H,\simulator}(1^\secpar) \right]\,,
  $$
  where $\pi$ denotes the proof output by the prover.
  Here, $H$ is a random oracle that the adversary has access to, and $H'$ is the state of the random oracle after the $\adv$'s output.
  Furthermore, $\mathsf{S}$ is a list of all input/output pairs of $\adv$'s invocations of $\simulator$.

  Similarly, the proof system is \emph{weakly simulation sound} if the following probability is negligible:
  $$
    \Pr\left[\verifier^{H'}(\statement,\pi)=\accept\land\statement\notin\lang(\relation)\land\statement\notin\mathsf{S} : (\statement,\pi)\gets\adv^{H,\simulator}(1^\secpar) \right]\,,
  $$
  where $\mathsf{S}$ now only contains the inputs of $\adv$'s invocations of $\simulator$.
\end{definition}

Finally, simulation extractability models the property that any adversary being able to generate a valid proof for a statement $\statement$ needs to know a valid witness $\witness$ for $\statement$, even if it had seen many simulated proofs before.
We omit a formal definition here, and refer, e.g., to Unruh~\cite{AC:Unruh17}.


\section{Constructions for $\Sigma$-Protocols}

This section is structured in two main parts: in \cref{sec:basicsigma}, we study the generic construction of $\Sigma$-protocols in prime-order groups. In \cref{sec:composition}, we study AND and OR-composition of the basic protocol.

For in-depth discussions of such protocols, we refer, e.g., to~\cite{bangerter05,AFRICACRYPT:Maurer09,DBLP:journals/dcc/Maurer15}.
\subsection{Basic $\Sigma$-Protocols in Prime-Order Groups}\label{sec:basicsigma}
A basic $\Sigma$-protocol for the relation:
\[
  \relation=\set{((\statement_1,\dots,\statement_m),(w_1,\dots,w_n)) : (\statement_1,\dots,\statement_m)=\varphi(w_1,\dots,w_n)}
\]
 for a group homomorphism $\varphi:\ZZ_p^n\to\GG^m$ is given by the following algorithms:

\begin{enumerate}
  \item\label{item:basic:p1}
    The prover's first algorithm $\prover_1(\vec \witness,\vec \statement)$ consists of the following steps:
    \begin{enumerate}
      \item\label{item:basic:p1:randomness}
        It chooses random elements $r_1,\dots,r_n\sample\ZZ_p$.
      \item
        It then computes $(\commitment_1,\dots,\commitment_m)\gets\varphi(r_1,\dots,r_n)$.
      \item
	The algorithm sets $\st\defeq (r_1,\dots,r_n)$ and $\vec \commitment\defeq(\commitment_1,\dots,\commitment_m)$.
      \item
        It finally outputs $(\vec \commitment,\st)$.
    \end{enumerate}
  \item\label{item:basic:p2}
    The prover's second algorithm $\prover_2(\vec \witness,\vec Y ,\challenge,\st)$ proceeds as follows:
    \begin{enumerate}
      \item
        It checks that $c\in\ZZ_p$ and aborts if this is not the case.
      \item
	It then parses $(r_1,\dots,r_n)\defeq \st$ and $(w_1,\dots,w_n)\defeq \vec \witness$.
      \item
        It computes its response as $s_i\defeq r_i+cw_i$ for $i=1,\dots,n$.
    \end{enumerate}
  \item\label{item:basic:v}
    The verifier's algorithm $\verifier(\vec \statement,\vec \commitment,\challenge,\vec \response)$ proceeds as follows:
    \begin{enumerate}
      \item It parses $(\response_1, \dots, \response_n) \defeq \vec \response$, $(\commitment_1, \dots, \commitment_m) \defeq \vec \commitment$, and $(\statement_1, \dots, \statement_m) = \vec \statement$.
      \item\label{item:basic:v:checks}
        It checks that $\response_i\in\ZZ_p$ for $i=1,\dots,n$ and $\commitment_j\in\GG$ for $j=1,\dots,m$, and outputs $0$ if this is not the case.
      \item
	It checks whether $(\commitment_1 + c\statement_1,\dots,\commitment_m + c\statement_m) = \varphi(s_1,\dots,s_n)$, and outputs $\accept$ if this is the case; otherwise, $\verifier$ outputs $\reject$.
    \end{enumerate}
  \item\label{item:basic:sim}
    The required simulator $\simulator(\vec \statement,c)$ for a basic $\Sigma$-protocol works as follows:
    \begin{enumerate}
      \item
        It parses $(\statement_1,\dots,\statement_m)\defeq \vec \statement$.
      \item\label{item:basic:sim:s}
        It chooses $\response_1,\dots,\response_n\sample\ZZ_p$.
      \item
        It sets $(\commitment_1,\dots,\commitment_m) \defeq \varphi(s_1,\dots,s_n) - c(\statement_1,\dots,\statement_m)$.
      \item
        Finally, the algorithm outputs the simulated transcript by setting $(\vec \commitment,\challenge,\vec \response)\defeq((\commitment_1,\dots,\commitment_m),\challenge,(\response_1,\dots,\response_n))$.
    \end{enumerate}
\end{enumerate}

\subsubsection{Proving linear relations among witnesses.}

  While the above protocol allows one to efficiently prove knowledge of a pre-image under a homomorphism, many protocols found in the literature require one to prove relations among witnesses.
  Specifically, they require to prove relations like the following:
\begin{equation*}
\relation=\set{((\statement_1,\dots,\statement_m),(w_1,\dots,w_n)) :
\begin{array}{c} (\statement_1,\dots,\statement_m)=\varphi(w_1,\dots,w_n) \\
                  A(w_1,\dots,w_n) = (b_1,\dots,b_k)\end{array}}\,,
\end{equation*}
where the matrix $A\in\ZZ_p^{k\times n}$ and vector $(b_1,\dots,b_k)\in\ZZ_p^k$ specify the system of linear equations.

Proving such a relation can easily by achieved by modifying the above protocol as follows:
\begin{itemize}
  \item
    In \cref{item:basic:p1:randomness}, the prover draws the randomnesses such that they satisfy the system of equations, i.e., such that $A(r_1,\dots,r_n)=(b_1,\dots,b_k)$.
  \item
    In \cref{item:basic:v:checks}, the verifier additionally checks that $A(s_1,\dots,s_n)=(c+1)(b_1,\dots,b_k)$ and outputs $\reject$ if this is not the case.
  \item
    In \cref{item:basic:sim:s}, the simulator draws the responses such that they satisfy the verification equations, i.e., such that $A(s_1,\dots,s_n)=(c+1)(b_1,\dots,b_k)$.
\end{itemize}


\subsubsection{Examples}

\paragraph{Example 1 (DLOG).}
Let $\GG$ be a group over an elliptic curve with prime order $p$.
Proving knowledge of the discrete logarithm $w$ of a point $Y$ in base $G$ means proving knowledge of $w\in\ZZ_p$ such that $Y=wG$.
For a description of this proof goal in the general case of residue classes, we also refer to~\cite[1.4.1]{zkproof-reference}.

Using the above notation, we have $\varphi:\ZZ_p^2\to\GG:x\mapsto xG$.
The protocol flow is then as depicted in~\cref{fig:dlog}.
    \begin{protocol}{Proving knowledge of a discrete logarithm.\\[-2.25em]}{fig:dlog}{bpt}
      \begin{tabular}{@{}l@{\hspace{2em}}c@{\hspace{-3em}}r@{}}
        $\prover\left(\witness,\statement,G\right)$ & & $\verifier\left(\statement,G\right)$  \\
        \hline  \\
      % -----------------------------P1-------------------------------
        $ r\sample\ZZ_p$ & &\\
        $ T \defeq rG$ & & \\
        & $\sendr{T}{100}$ \\[2 ex]
      % -----------------------------CHALLENGE-------------------------------
        & & $c \sample \ZZ_p$ \\
        & $\sendl{c}{100}$ & \\[2 ex]
      % -----------------------------P2-------------------------------
        $ s \defeq r + cw$\\
        & $\sendr{s}{100}$ \\[2 ex]
      % -----------------------------V-------------------------------
        & & Return $\accept$ iff \\
        & & $T + cY = sG$ \\
      \end{tabular}
    \end{protocol}

For a given challenge $c\in\ZZ_p$, the simulator chooses $s\sample\ZZ_p$, and sets $T\gets sG-cY$.
It then outputs the simulated transcript $(\commitment,\challenge,s)$.


\paragraph{Example 2 (DLEQ).}
Let $\GG$ be a group over an elliptic curve with prime order $p$.
Proving equality of the known discrete logarithm $w$ of $\statement_1$ in base $G$ and $\statement_2$ in base $H$ means proving knowledge of $(w_1,w_2)\in\ZZ_p$ such that $\statement_1=w_1G$ and $\statement_2=w_2H$, and $w_1=w_2$.

Using the above notation, we have $\varphi:\ZZ_p\to\GG^2:(x_1,x_2)\mapsto (x_1G,x_2H)$.
The linear system of equations $A(w_1,w_2)=b$ is given by $w_1-w_2=0$.
The protocol flow is then as depicted in~\cref{fig:dleq}.
    \begin{protocol}{Proving knowledge of equality of two discrete logarithms.\\[-2.25em]}{fig:dleq}{b}
      \begin{tabular}{@{}l@{\hspace{-4em}}c@{\hspace{-3em}}r@{}}
        $\prover\left( (w_1,w_2),(\statement_1,\statement_2),(G,H)\right)$ & & $\verifier\left((\statement_1,\statement_2),(G,H)\right)$  \\
        \hline  \\
      % -----------------------------P1-------------------------------
        $ r_1,r_2\sample\ZZ_p$ such that $r_1-r_2=0$ & &\\
        $ \commitment_1 \defeq r_1G$ & & \\
        $ \commitment_2 \defeq r_2H$ & & \\
        & $\sendr{\commitment_1,\commitment_2}{100}$ \\[2 ex]
      % -----------------------------CHALLENGE-------------------------------
        & & $c \sample \ZZ_p$ \\
        & $\sendl{c}{100}$ & \\[2 ex]
      % -----------------------------P2-------------------------------
        $ s_1 \defeq r_1 + cw_1$\\
        $ s_2 \defeq r_2 + cw_2$\\
        & $\sendr{s_1,s_2}{100}$ \\[2 ex]
      % -----------------------------V-------------------------------
        & & Return $\accept$ iff \\
        & & $\commitment_1 + c\statement_1 = s_1G$ \\
        & & $\commitment_2 + c\statement_2 = s_2H$ \\
        & & and $s_1-s_2=0$.
      \end{tabular}
    \end{protocol}

For a given challenge $c\in\ZZ_p$, the simulator chooses $s_1,s_2\sample\ZZ_p$ such that $s_1-s_2=0$, and sets $\commitment_1\gets s_1G-c\statement_1$ and $\commitment_2\gets s_2H - c\statement_2$.
It then outputs the simulated transcript $((\commitment_1,\commitment_2),\challenge,(s_1,s_2))$.

\paragraph{Example 3 (DLEQ; alternative).}
The same proof goal as in the previous example can also be achieved by considering a slightly different homomorphism, which directly encodes the linear relation, that is $\varphi:\ZZ_p\to\GG^2:x\mapsto (xG,xH)$.
The protocol flow is then as depicted in~\cref{fig:dleq_2}.
    \begin{protocol}{Proving knowledge of equality of two discrete logarithms (alternative).\\[-2.25em]}{fig:dleq_2}{t}
      \begin{tabular}{@{}l@{\hspace{2em}}c@{\hspace{-3em}}r@{}}
        $\prover \left(\witness,(\statement_1,\statement_2),(G,H) \right)$ & & $\verifier \left((\statement_1,\statement_2),(G,H)\right)$  \\
        \hline  \\
      % -----------------------------P1-------------------------------
        $ r\sample\ZZ_p$ & &\\
        $ \commitment_1 \defeq rG$ & & \\
        $ \commitment_2 \defeq rH$ & & \\
        & $\sendr{\commitment_1,\commitment_2}{100}$ \\[2 ex]
      % -----------------------------CHALLENGE-------------------------------
        & & $c \sample \ZZ_p$ \\
        & $\sendl{c}{100}$ & \\[2 ex]
      % -----------------------------P2-------------------------------
      $s \defeq r + cw $& & \\
      & $\sendr{s}{100}$\\[2ex]
      % -----------------------------V-------------------------------
        & & Return $\accept$ iff \\
        & & $\commitment_1 + c\statement_1 = sG$ \\
        & & and $\commitment_2 + c\statement_2 = sH$. \\
      \end{tabular}
    \end{protocol}

For a given challenge $c\in\ZZ_p$, the simulator chooses $s\sample\ZZ_p$, and sets $\commitment_1\gets sG-c\statement_1$ and $\commitment_2\gets sH - c\statement_2$.
It then outputs the simulated transcript $((\commitment_1,\commitment_2),\challenge,s)$.


\begin{remark}
  The two protocols illustrated prove the same statement, but achieve this via different approaches.
  The first protocol uses the more general framework of liner relations among witnesses introduced above.
  Alternatively, as shown in the second protocol, the linear relation can also be realized by  directly incorporating the linear relation into the proof goal, thereby achieving a slightly shorter proof size (as the prover's last message consists of one element of $\ZZ_p$ less).

  However, when proving inhomogeneous linear relations, incorporating the relation into the homomorphism also requires some additional computations in the target group, which in certain cases might compensate the advantage of a smaller proof size.
\end{remark}

\paragraph{Example 4 (REP).}
Let $\GG$ be a group over an elliptic curve of prime order $p$.
Proving knowledge of a valid opening of a Pedersen commitment means proving knowledge of $w_1,w_2\in\ZZ_p$ such that $Y=w_1G + w_2H$.

Using the above notation, we have $\varphi:\ZZ_p^2\to\GG:(x_1,x_2)\mapsto x_1G + x_2H$.
The protocol flow is then as depicted in~\cref{fig:rep}.
    \begin{protocol}{Proving knowledge of representation.\\[-2.25em]}{fig:rep}{hbpt}
      \begin{tabular}{@{}l@{\hspace{2em}}c@{\hspace{-3em}}r@{}}
        $\prover \left( (w_1,w_2),Y,(G,H)\right)$ & & $\verifier \left(Y,(G,H)\right)$  \\
        \hline  \\
      % -----------------------------P1-------------------------------
        $ r_1\sample\ZZ_p$ & &\\
        $ r_2\sample\ZZ_p$ & &\\
        $ T \defeq r_1G + r_2H$ & & \\
        & $\sendr{T}{100}$ \\[2 ex]
      % -----------------------------CHALLENGE-------------------------------
        & & $c \sample \ZZ_p$ \\
        & $\sendl{c}{100}$ & \\[2 ex]
      % -----------------------------P2-------------------------------
        $ s_1 \defeq r_1 + cw_1$\\
        $ s_2 \defeq r_2 + cw_2$\\
        & $\sendr{s_1,s_2}{100}$ \\[2 ex]
      % -----------------------------V-------------------------------
        & & Return $\accept$ iff \\
        & & $T + cY = s_1G + s_2H$ \\
      \end{tabular}
    \end{protocol}

For a given challenge $c\in\ZZ_p$, the simulator chooses $s_1,s_2\sample\ZZ_p$, and sets $T\defeq s_1G + s_2H -cY$.
It then outputs the simulated transcript $(\commitment,\challenge,(s_1,s_2))$.

\paragraph{Example 5 (DH).}
Let $\GG$ be a group over an elliptic curve with prime order $p$.
Proving knowledge of the exponents of a valid Diffie-Hellman triple means proving knowledge of $w_1,w_2\in\ZZ_p$ such that $\statement_1=w_1G$, $\statement_2=w_2G$, and $\statement_3=w_1 w_2 G$.
Yet, the mapping $\ZZ_p^2\to\GG^3:(x_1,x_2)\mapsto (x_1G,x_2G,x_1x_2G)$ is not a homomorphism, and consequently the basic protocol presented before cannot be deployed directly.
However, the required multiplicative relation can be proven by observing that the proof goal is equivalent to $\statement_1=w_1G$, $\statement_2=w_2G$, and $\statement_3=w_2\statement_1$, leading the homomorphism $\varphi:\ZZ_p^2\to\GG^3:(x_1,x_2)\mapsto(x_1G,x_2G,x_2\statement_1)$.

The protocol flow is then as depicted in~\cref{fig:dh}.
    \begin{protocol}{Proving knowledge of representation.\\[-2.25em]}{fig:dh}{t}
      \begin{tabular}{@{}l@{\hspace{-3em}}c@{\hspace{-2em}}r@{}}
        $\prover\left( (w_1,w_2),(\statement_1,\statement_2,\statement_3),G)\right)$ & & $\verifier\left((\statement_1,\statement_2,\statement_3),G \right)$  \\
        \hline  \\
      % -----------------------------P1-------------------------------
        $ r_1\sample\ZZ_p$ & &\\
        $ r_2\sample\ZZ_p$ & &\\
        $ \commitment_1 \defeq r_1G$ & & \\
        $ \commitment_2 \defeq r_2G$ & & \\
        $ \commitment_3 \defeq r_2\statement_1$ & & \\
        & $\sendr{\commitment_1,\commitment_2,\commitment_3}{100}$ \\[2 ex]
      % -----------------------------CHALLENGE-------------------------------
        & & $c \sample \ZZ_p$ \\
        & $\sendl{c}{100}$ & \\[2 ex]
      % -----------------------------P2-------------------------------
        $ s_1 \defeq r_1 + cw_1$\\
        $ s_2 \defeq r_2 + cw_2$\\
        & $\sendr{s_1,s_2}{100}$ \\[2 ex]
      % -----------------------------V-------------------------------
        & & Return $\accept$ iff \\
        & & $\commitment_1 + c\statement_1 = s_1G$ \\
        & & $\commitment_2 + c\statement_2 = s_2G$ \\
        & & and $\commitment_3 + c\statement_3 = s_2\statement_1$ \\
      \end{tabular}
    \end{protocol}

For a given challenge $c\in\ZZ_p$, the simulator chooses $s_1,s_2\sample\ZZ_p$, and sets $\commitment_1\defeq s_1G -c\statement_1$, $\commitment_2\defeq s_2G-c\statement_2$, and $\commitment_3\defeq s_2\statement_1-c\statement_3$.
It then outputs the simulated transcript $((\commitment_1,\commitment_2,\commitment_3),\challenge,(s_1,s_2))$.

As shown in this example, and in contrast to linear relations, multiplicative relations among witnesses typically require a reformulation of the proof goal in order to be compatible with the generic protocol presented above.
We refer, e.g., to Krenn~\cite{krenn12} for generic techniques.

\subsection{Composition of $\Sigma$-Protocols}
\label{sec:composition}
\label{sec:or-comp}
\label{sec:and-comp}
  In this section, we recap composition techniques of $\Sigma$-protocols.
  Specifically, we define mechanisms for proving knowledge of multiple independent witnesses (\emph{AND composition}), and for proving knowledge for one out of a set of witnesses (\emph{OR composition}).
  Without loss of generality, the techniques presented in the following focus on the composition of two protocols;
  proving knowledge of more than two witnesses, or for out of a larger set of witnesses, can directly be achieved by iteratively deploying the techniques.

  For the rest of this section, we let $(\prover_1^0,\prover_2^0,\verifier^0)$ and $(\prover_1^1,\prover_2^1,\verifier^1)$ be the specifications of two $\Sigma$-protocols for two relations $\relation^0$ and $\relation^1$, and let $\simulator^0$ and $\simulator^1$ be their simulators.

  Furthermore, for the ease of presentation, we assume that all protocols to be composed are based on groups of the same prime order $p$.
  If this is not the case, the constructions can easily be adapted by setting the challenge set to the smaller of the two challenge sets.

\subsubsection{AND Composition.}
  In the following we explain how to construct a $\Sigma$-protocol proving knowledge of multiple independent witnesses.
  That is, the algorithms specified below constitute a $\Sigma$-protocol for the following relation:
\[
  \relation^\land = \set{
    ((\statement^0,\statement^1),(\witness^0,\witness^1) : (\statement^0,\witness^0)\in \relation^0 ~\land~ (\statement^1,\witness^1)\in\relation^1}\,.
\]


\begin{enumerate}
  \item
    The prover's first algorithm $\prover_1(\vec \witness, \vec\statement)$ consists of the following steps:
    \begin{enumerate}
      \item
        The algorithm parses $(\witness^0,\witness^1)\defeq \vec \witness$ and $(\statement^0,\statement^1)\defeq \vec \statement$.
      \item
        It computes $(\commitment^0,\st^0)\gets\prover_1^0(\witness^0, \statement^0)$ and $(\commitment^1,\st^1)\gets\prover_1^1(\witness^1, \statement^1)$.
      \item
	The algorithm outputs $(\vec \commitment,\st) \defeq ((\commitment^0,  \commitment^1),(\st^0,\st^1))$.
    \end{enumerate}
  \item
    The prover's second algorithm $\prover_2(\vec \witness,\vec \statement,\challenge,\st)$ proceeds as follows:
    \begin{enumerate}
      \item
        It checks that $c\in\ZZ_p$ and aborts if this is not the case.
      \item
	It parses $(\st^0,\st^1)\defeq \st$
      \item
        It computes $s^0\gets\prover_2^0(\witness^0,\statement^0,\challenge,\st^0)$ and $s^1\gets\prover_2^1(\witness^1,\statement^1,\challenge,\st^1)$.
      \item
        It outputs $\vec \response\defeq(s^0,s^1)$.
    \end{enumerate}
  \item
    The verifier's algorithm $\verifier(\vec \statement, \vec \commitment,\challenge,\vec \response)$ proceeds as follows:
    \begin{enumerate}
      \item
        It  parses $(s^0,s^1)\defeq \vec \response$.
      \item
	The algorithm outputs $\verifier^0(\statement^0, \commitment^0,\challenge, \response^0)\land\verifier^1(\statement^1, \commitment^1,\challenge, \response^1)$.
    \end{enumerate}
  \item
    The required simulator $\simulator(\vec Y,c)$ works as follows:
    \begin{enumerate}
      \item
        It parses $(\statement^0,\statement^1)\defeq \vec Y$.
      \item
        It chooses $c\sample\ZZ_p$.
      \item
        It computes $(\commitment^0,\challenge,s^0)\gets\simulator^0(\statement^0,c)$ and $(\commitment^1,\challenge,s^1)\gets\simulator^1(\statement^1,c)$.
      \item
        Finally, the algorithm then outputs $(\vec \commitment,\challenge, \vec \response)\defeq((\commitment^0, \commitment^1),\challenge,(s^0,s^1))$.
    \end{enumerate}
\end{enumerate}


\subsubsection{OR Composition.}
  In the following we explain how to construct a $\Sigma$-protocol proving knowledge of one out of a set of witnesses.
  That is, the algorithms specified below constitute a $\Sigma$-protocol for the following relation:
\[
  \relation^\lor = \set{
    ((\statement^0,\statement^1),(\witness^0,\witness^1) :
    (\statement^0,\witness^0)\in \relation^0 ~\lor~ (\statement^1,\witness^1)\in\relation^1}\,.
\]

  In the following protocol specification, let $j$ be such that $w^j$ is known to the prover, whereas without loss of generality $w^{1-j}$ is assumed to be unknown to the prover.
\begin{enumerate}
  \item
    The prover's first algorithm $\prover_1(\vec \witness, \vec \statement)$ consists of the following steps:
    \begin{enumerate}
      \item
        It parses $(\witness^0,\witness^1)\defeq \vec \witness$ and $(\statement^0,\statement^1)\defeq \vec \statement$, where $w^{1-j}=\bot$.
      \item
        It computes $(\commitment^j,\st^j)\gets\prover_1^j(Y^j,w^j)$.
      \item
        It computes a simulated transcript for the unknown witness by choosing $c^{1-j}\sample\ZZ_p$ and setting $(\commitment^{1-j},c^{1-j},s^{1-j})\gets\simulator^{1-j}(Y^{1-j},c^{1-j})$.
      \item
	The algorithm outputs $(\vec \commitment,\st) \defeq ((\commitment^0,\commitment^1),(\st^j,c^{1-j},s^{1-j}))$.
    \end{enumerate}
  \item
    The prover's second algorithm $\prover_2(\vec \witness, \vec \statement,\challenge,\st)$ proceeds as follows:
    \begin{enumerate}
      \item
        It checks that $c\in\ZZ_p$ and aborts if this is not the case.
      \item
	It parses $(\st^j,c^{1-j},s^{1-j})\defeq\st$.
      \item
        It computes $c^j\defeq c-c^{1-j}$, and sets $s^j\gets\prover_2^j(w^j,Y^j,c^j,\st^j)$.
      \item
        It computes $s^0\gets\prover_2^0(\witness^0,\statement^0,\challenge,\st^0)$ and $s^1\gets\prover_2^1(\witness^1,\statement^1,\challenge,\st^1)$.
      \item
        It outputs $\vec \response\defeq(\response^0,\response^1, c^0)$.
    \end{enumerate}
  \item
    The verifier's algorithm $\verifier(\vec \statement, \vec \commitment,\challenge,\vec \response)$ proceeds as follows:
    \begin{enumerate}
      \item
        It  parses $(\response^0, \response^1, \challenge^0)\defeq \vec \response$.
      \item
        It sets $c^1\defeq c-c^0$.
      \item
	The algorithm outputs $\verifier^0(\statement^0, \commitment^0,c^0,s^0)\land\verifier^1(\statement^1, \commitment^1,c^1,s^1)$.
    \end{enumerate}
  \item
    The required simulator $\simulator(\vec Y,c)$ works as follows:
    \begin{enumerate}
      \item
        It parses $(\statement^0,\statement^1)\defeq \vec \statement$.
      \item
        It chooses a random $c^0$ in $\ZZ_p$ and computes $c^1\defeq c-c^0$.
      \item
        It then computes $(\commitment^0,\challenge^0, \response^0)\gets\simulator^0(\commitment^0,\challenge^0)$ and $(\commitment^1,\challenge^1,\response^1)\gets\simulator^1(\statement^1,\challenge^1)$.
      \item
        Finally, the algorithm then outputs $(\vec \commitment,\challenge,\vec s)\defeq ((\commitment^0,\commitment^1),\challenge,(s^0,s^1,c^0))$.
    \end{enumerate}
\end{enumerate}

\subsection{Achieving Non-Interactivity -- The Fiat-Shamir Transform}\label{sec:fs}
% \marynote{Considering you are stressing the importance of hashing the instance, I would send the instance in the first message of the interactive versions as well.}
All protocols described so far require three messages being exchanged between the prover and the verifier.
However, communication rounds are often considered expensive from an efficiency point of view, and for many applications interactivity is not desirable.

\begin{remark}
The interactive version of $\Sigma$-protocols presented in this paper is unfit for practical applications. For those applications where latency is not a problem, we direct the reader towards~\cref{XXX} for general techniques. In this submission, we focus on the non-interactive transform.
\end{remark}


We describe two ways for achieving non-interactivity. Both variants require identical computations on the prover's side.
The first allows for efficient batching, but requires point validation and (depending on the hash function, or the elliptic curve chosen) might lead to
slightly larger proof sizes. The second requires no point validation and only has the hash value.
We call the first variant \emph{batchable}, and the latter \emph{short}.

The constructions are based on the seminal work of Fiat and Shamir~\cite{C:FiaSha86} and subsequent work, e.g., by Bernhard et al.~\cite{AC:BerPerWar12}.
The underlying idea of the so-called Fiat-Shamir transform is to simulate the verifier's random challenge by means of a random oracle, depending on the first message computed by the prover.
More precisely, the challenge is computed as
$c\defeq\hash(\vec \statement,\vec \commitment, \ctx, \stag)$,
where $\statement$ is the public image for which knowledge of a witness is proven, $\commitment$ is the prover's first message from the $\Sigma$-protocol, $\stag$ is a (possibly empty, variable-length) label attached to the proof, and
the context string $\ctx$ is a tuple $\ctx = (\domsepctx, \curvectx, \generatorsctx, \idctx)$ containing the following application-specific information:
\begin{itemize}
  \item $\domsepctx$, a string determining uniquely the name of the target application (and the proof type);
  \item $\curvectx$, a label identifying uniquely the group (e.g.\ \verb|secp-256|)
  \item $\generatorsctx$,
    a full description of the algebraic setting and proof goal (e.g., group generators, and constants fixed in the protocol) to achieve non-malleability;
  \item \textsf{id},
    local context information (e.g., session identifiers of higher level protocols) to avoid replay-attacks, or shared randomness or a timestamp to guarantee freshness of the proof.
\end{itemize}
The tag $\stag$ contains an arbitrary string, possibly empty, that the prover can attach to the proof. This can allow to construct e.g. signatures and ring signatures.
We discuss more in details the content the hash in \cref{sec:instantiation}.

\subsubsection{Batchable form}


\begin{enumerate}
  \item
    The prover's algorithm $\batchprover(\vec \witness, \vec \statement,\ctx, \stag)$ works as follows:
    \begin{enumerate}
      \item
        The algorithm first computes $(\vec \commitment,\st)\gets\prover_1(\vec \witness, \vec \statement)$.
      \item
        It computes the challenge by setting $c\defeq\hash(\vec \commitment, \vec \statement,\ctx, \stag)$.
      \item
        The algorithm defines $\vec \response\gets\prover_2(\vec \witness, \vec \statement,\challenge,\st)$.
      \item
        The algorithm outputs $(\vec \commitment, \vec \response)$.
    \end{enumerate}
  \item
    The verifier's algorithm $\batchverifier(\vec \statement, \ctx, \stag, (\vec \commitment,\vec s))$ works as follows:
    \begin{enumerate}
      \item
        It recomputes the challenge as $c\gets\hash(\vec \statement, \vec \commitment, \ctx, \stag)$.
      \item
        It outputs whatever $\verifier(\vec \statement,\vec \commitment,\challenge,\vec \response)$ outputs.
    \end{enumerate}
\end{enumerate}


\paragraph{Verification equation.}
The batchable form can take advantage of the following fact.
Given the single verification equations of the form:
\[
   \commitment_i + c_i Y_i = \sum_j s_{i, j} G_j
\]
for $i=0, \dots,\ell-1$,
%(So, $T \in \GG^\ell$, $c \in \ZZ_p^\ell$ and $s \in \ZZ_p^{\ell \times m}$ and $\mat G \in \GG^{m \times \ell}$.)
the verifier can sample a random vector of coefficients $a \in \ZZ_p^\ell$ instead test that:
\[
  \left(\sum_{i=0}^{\ell-1} a_i \commitment_i\right) + \left(\sum_{i=0}^{\ell-1} a_i \cdot  c_i \statement_i \right) = \left(\sum_{i=0}^{\ell-1} a_i \cdot \response_i G_i\right).
\]
If the matrix $G_{i, j}$ of generators has identical rows, by linearity the right-hand side can be computed as a single scalar product.
If the statements $\statement_i$'s have identical rows, by linearity the second term in the equation can be computed as a single scalar product.
The random vector $\vec a$ can be \emph{deterministically} generated by fixing $a_0 \defeq 1$ and setting $(a_1, \dots, a_{\ell-1}) \defeq \prg(\vec Y, \vec T,  \challenge, \vec s)$~\cite{bip-schnorr}.

\subsubsection{Short form}
\begin{enumerate}
  \item
    The prover's algorithm $\shortprover(\vec \witness, \vec \statement,\ctx, \stag)$ works as follows:
    \begin{enumerate}
      \item
        The algorithm first computes $(\vec \commitment,\st)\gets\prover_1(\vec \witness, \vec \statement)$.
      \item
        It computes the challenge by setting $c\defeq\hash(\vec \commitment, \vec \statement,\ctx, \stag)$.
      \item
        The algorithm defines $\vec \response\gets\prover_2(\vec \witness,\vec \statement, \challenge,\st)$.
      \item
        The algorithm outputs $(\challenge,\vec \response)$.
    \end{enumerate}
  \item
    The verifier's algorithm $\shortverifier(\vec \statement, \ctx, \stag, (\challenge, \vec \response))$ works as follows:
    \begin{enumerate}
      \item\label{item:fslong:v:recomputet}
        The algorithm recomputes the first message $\vec \commitment$ by running the appropriate steps of the simulator $\simulator$.

         More precisely, we stress that, on input a challenge $\challenge$, all simulators introduced so far first draw a response $\response$, and then compute the commitment $\commitment$ from $\challenge$ and $\response$.
        Instead of sampling $\response$, the algorithm now uses its input value to recompute $\commitment$ according to the remaining steps of the simulator.
        \item
        The algorithm checks that $c=\hash(\vec \commitment, \vec \statement, \ctx, \tau)$ and rejects if this is not the case.
    \end{enumerate}
\end{enumerate}




\subsection{Achieving Concurrent Zero-Knowledge}\label{sec:concurrent}
The basic protocols presented above cannot directly be used for practical applications, as the zero-knowledge property does not hold against malicious verifiers.
While for most applications the Fiat-Shamir heuristic is the preferred way to also address this challenge, there might be cases where interactive protocols are still preferable, e.g., for deniability reasons.
The following construction, due to Damg\r{a}rd~\cite{EC:Damgard00}, allows one to turn any $\Sigma$-protocol into a concurrently zero-knowledge version also against malicious adversaries.

In the following, $({\sf Commit}, {\sf VerCommit})$ is a commitment scheme, where the interfaces are as specified in Benarroch et al.~\cite[Section 4.3]{becafi19}.
The commitment scheme used in the following is required to be a trapdoor commitment scheme (cf., e.g., Fischlin~\cite{fischlin01} for an in-depth discussion of such schemes), with a natural candidate being the scheme introduced by Pedersen~\cite{C:Pedersen91}.
\begin{enumerate}
  \item
    The verifier's first algorithm $\verifier_1(\vec \statement)$ proceeds as follows:
    \begin{enumerate}
      \item
	It samples $\challenge\sample\ZZ_p$ and computes $(com,o)\defeq{\sf Commit}(ck,\challenge)$.
      \item
        It sets $\st_\verifier\defeq(\challenge,o)$.
      \item
        It sends $com$ to the prover.
    \end{enumerate}
  \item
    The prover's first algorithm $\prover_1(\vec \witness,\vec \statement,com)$ consists of the following steps:
    \begin{enumerate}
      \item
	The algorithm computes $(\vec \commitment',\st') \defeq \prover_1(\vec \witness,\vec \statement)$.
      \item
	It outputs $(\vec \commitment,\st) \defeq (\vec \commitment',(\st',com))$.
    \end{enumerate}
  \item
    The verifier's second algorithm $\verifier_1(\vec \statement,\vec \commitment,\st_\verifier)$ proceeds as follows:
    \begin{enumerate}
      \item
        It parses $\st_\verifier=(\challenge,o)$.
      \item
        It sends $(\challenge,o)$ to the prover.
    \end{enumerate}
  \item
    The prover's second algorithm $\prover_2(\vec \witness,\vec \statement,\challenge,o,\st)$ proceeds as follows:
    \begin{enumerate}
      \item
        The algorithm parses $\st=(\st',com)$.
      \item
        It checks that ${\sf VerCommit}(com,\challenge,o)=\accept$ and aborts otherwise.
      \item
        It outputs $s\defeq\prover_2(\vec \witness, \vec \statement,\challenge,\st')$.
    \end{enumerate}
  \item
    The verifier's final algorithm $\verifier_3(\vec \statement,\vec \commitment,\challenge,\response)$ proceeds as follow:
    \begin{enumerate}
      \item
	The algorithm outputs $\verifier(\vec \statement,\vec \commitment,\challenge,\response)$.
    \end{enumerate}
\end{enumerate}




\section{Security Considerations}

In the following, we give a concise overview of the most important security guarantees provided by the constructions presented above.
For full details and proofs, we refer to the original literature.

\begin{description}
  \item[$\Sigma$-Protocols.]
  The protocol presented in \cref{sec:basicsigma} is a $\Sigma$-protocol, if $\GG$ is a cyclic group of prime order $p$, and $\varphi:\ZZ_p^n\to\GG^m$ is a group homomorphism.

  If $\varphi$ is non-trivial (there exists $\vec x\in\ZZ_p^n$ such that $\varphi(\vec x)\ne (1,\dots,1)\in\GG^m$), the protocol has unpredictable commitments.
  Finally, if $\varphi$ is an injective function, the protocol has unique responses.

  For details we refer, e.g., to~\cite{cramer97}.

  \item[Composition.]
    The composed protocols presented in \cref{sec:composition} are $\Sigma$-protocols if the individual protocols are $\Sigma$-protocols, see, e.g.,~\cite{C:CraDamSch94}.

  If at least one of the composed protocols has unpredictable commitments, then so have the protocols for $\relation^\land$ and $\relation^\lor$.

  If both protocols have unique responses, then so has the protocol for $\relation^\land$.
  Note that unique responses are not preserved under OR-compositions.

  \item[Proof of Knowledge.]
    All protocols presented in \cref{sec:basicsigma,sec:composition} are proofs of knowledge, see Damg\r{a}rd~\cite{damgard04}.
  \item[Concurrent Zero-Knowledge.]
    The protocol in \cref{sec:concurrent} is concurrently zero-knowledge against arbitrary verifiers if the used commitment scheme is a trapdoor commitment scheme, cf.~\cite{EC:Damgard00}.
%
  \item[Completeness.]
    For all the $\Sigma$-protocols presented above, the Fiat-Shamir transform is complete.


    For a proof we refer to Unruh~\cite{AC:Unruh17}, which uses the fact that all presented protocols are complete and have unpredictable commitments;
    Unruh also gives a surprising counter-example in case that commitments are not unpredictable.
  \item[Zero-Knowledge.]
    For all $\Sigma$-protocol presented above, the Fiat-Shamir transform yields a zero-knowledge protocol in the random oracle model.

    For a proof we refer to Faust et al.~\cite{INDOCRYPT:FKMV12} and Unruh~\cite{AC:Unruh17}. These security guarantees also hold against a quantum attacker, and rely on the honest-verifier zero-knowledge property of $\Sigma$-protocols and the fact that the commitments in all our protocols are unpredictable.
  \item[Soundness.]
    If a $\Sigma$-protocol has a negligible soundness error, then the Fiat-Shamir transform is sound according to~\cref{def:soundness}.
    This security guarantee also holds against quantum attackers.

    For a proof we refer to Pointcheval and Stern~\cite{JC:PoiSte00} and Unruh~\cite{AC:Unruh17}.
    {Existence of a straight-line extractor for $\Sigma$-protocols was proposed by Fuchsbauer et al.~\cite{C:FucKilLos18}, but under the (stronger) setting of the algebraic group model.}

  \item[Simulation soundness.]
    For all protocols presented in \cref{sec:basicsigma,sec:composition}, the Fiat-Shamir transform is  weakly simulation-sound.
    If the protocol additionally has unique responses, then the Fiat-Shamir transform is  strongly simulation-sound.
    These security guarantees also holds against quantum attackers.

    For a proof we refer to Unruh~\cite{AC:Unruh17} and Faust et al.~\cite{INDOCRYPT:FKMV12}.
  \item[Simulation extractability.]
    For all protocols presented in \cref{sec:basicsigma,sec:composition}, the Fiat-Shamir transform is  simulation-sound extractable.

    For a proof we refer to Bernhard et al.~\cite{AC:BerPerWar12}.
\end{description}

\section{Instantiation}
\label{sec:instantiation}

\begin{table}[t]
  \caption{Summary of open-source projects that implement $\Sigma$-protocols, along with features supported.
  INT stands for \emph{interactive}; FS stands for \emph{Fiat-Shamir}.
  Most of this table's data comes from the work of Lueks et al.~\cite{zksk}.
  \label{table:implementations}}
  \centering
  \setlength{\tabcolsep}{4pt}
  \begin{adjustbox}{max width=\textwidth}
  \begin{tabular}{lcccccc}
  \toprule
  Project & Language & AND-composition & OR-composition & INT & FS \\
  \hline
  \verb|Cashlib|~\cite{USENIX:MEKHL10} & C++ & \cmark & \xmark & \xmark & \cmark \\
  \verb|Emmy|~\cite{emmy} & Go &  \xmark & \xmark & \cmark & \xmark \\
  %\verb|Helios| \cite{USENIX:Adida08} & \\
  \verb|Kyber|~\cite{kyber} & Go &  \cmark & \cmark & \cmark & \cmark \\
  \verb|SCAPI| \cite{scapi} &  C++ & \cmark & \cmark & \cmark & \cmark\\
  \verb|YAZKC|~\cite{ESORICS:ABBKSS10,CCS:ABBBKZ12} & C & \cmark & \cmark& \cmark & \cmark \\
  \verb|zkp|~\cite{zkp} & Rust & \cmark & \xmark & \xmark & \cmark \\
  \verb|zksk|~\cite{zksk} & Python & \cmark & \cmark & \cmark & \cmark\\
  \bottomrule
  \end{tabular}
\end{adjustbox}
\end{table}

\marynote{Would be very interested to know which of these if any have been formally audited and by whom. Also what groups are supported.}
In this section, we consider the concrete security of $\Sigma$-protocols and illustrate the main points that should be considered when implementing them.
In \cref{table:implementations}, we report the implementations that we are currently aware of.
This table is greatly inspired from the remarkable bibliographic work of Lueks et al.~\cite{zksk}.
\paragraph{Choice of a group.} We advise for the use of prime-order elliptic curves of size either 256 or 512 bits, depending on the desired security of the upper layers in the protocol\footnote{For instance, proving a DH relation with one fixed group element such as a public key, might expose the protocol to cryptanalytic attacks such as Brown-Gallant~\cite{EPRINT:BroGal04} and Cheon‚Äôs attack~\cite{EC:Cheon06}, and some implementations might opt for larger curve sizes. We consider these attacks out of scope for this standardization effort, and believe this analysis should be deferred to the concrete security study of the larger protocol.}.
Concretely, we see fit NIST's \verb|p-521| and \verb|p-256|~\cite{fips2}; SECG's \verb|secp256k1|~\cite{SECG}, or standardized prime-order group abstractions over non prime-order groups, such as Decaf or Ristretto~\cite{C:Hamburg15,cfrg-ristretto-decaf}\footnote{We are aware of the threats reported in
\url{https://safecurves.cr.yp.to/}.
It's however not clear what should be the alternatives, and if dropping their support would hinder adoption.
}.
We note that there exists already standards for removing small cofactors in elliptic curves~\cite{rfc2785}.
However we believe that the complexity added by integrating the handling of the cofactor within the verification equations is deleterious for the other supported curves.

We think pairing-friendly curves, such as BLS12-381~\cite{bls12}, should also be considered for inclusion under relevant assumptions for bilinear groups, such as XDH when dealing with DH triples.
\minote{Add point compression and point representation.\\
To represent point within the elliptic curve we opt for encoding the full $x$-coordinate, and implicitly choosing the $y$ that is even.}


 \paragraph{Choice of the hash functions.} We advise for the use of consolidated, cryptographically secure hash functions such as \verb|SHA2|, \verb|SHA3|, and \verb|BLAKE2|, \verb|BLAKE3|\footnote{We did not examine closely algebraic hashes for this draft, but we stress that their adoption could be appealing for a number of applications requiring recursive proofs. Unfortunately, this requires a much deeper cryptanalysis within a working group.}.
 In the non-interactive $\Sigma$-protocols, the image of the random oracle is assumed to be over the field, and translating the output of the hash function (in $\bin^*$) into an integer mod $p$ requires care to preserve indifferentiability.
To the best of our knowledge, the best options for performing this operation are the following:
\begin{enumerate}[label=$(\alph*)$]
  \item\label{item:truncate-128}  Truncating the output of the hash to 128 bits, and interpreting it as a small integer mod $p$.
  Despite being the most efficient option at our disposal, it is unclear if the collision probability of $2^{-64}$ could be too small for certain applications;
  \item\label{item:truncate-256}  Truncating the output of the hash to 256 bits, and then reducing mod $p$.
  This is by far the most natural approach; however, the output distribution could be potentially far from uniformly random, in terms of statistical distance.
 Consider e.g.\ a prime $p$ that is close to $3/4 \cdot 2^{256}$. Reducing a random $256$-bit integer modulo this $p$ yields a value that is in the range $[0, p / 3]$ with probability roughly $1/2$~\cite{hash-to-curve}.
  We remark that, nonetheless, min-entropy wise this will cost at most one bit of security.
  Namely, the chances of guessing a specific challenge is still than negligible despite the bias.
  \minote{check that curves proposed have a very small range. }
  \item\label{item:truncate-cfrg} Truncating the output of the hash to $\ceil{\log_2 p} + \kappa$ bits (where $\kappa$ is the targeted statistical
  security level), and then reducing mod $p$.
  This is essentially the procedure
  \verb|hash_to_field| as described in~\cite[Section 5]{hash-to-curve}.
  This approach leads to a random value statistically close ($2^{-\kappa}$) to a value sampled uniformly at random in $\ZZ_p$.
  \item Rejection sampling, which consists in sampling uniformly at random in the interval $[0, 2^\secpar]$, until a value in $[0, p]$ is found.
  Unfortunately, since the hash function is used also for hashing the initial (secret) randomness used for computing the commitment, this method is undesirable due to the difficulty of implementing in constant-time (which could lead a secret for the deterministic computation of the commitment).
\end{enumerate}
Despite options \cref{item:truncate-256,item:truncate-cfrg} are the most fit for computing the challenge, only option \cref{item:truncate-cfrg} is suitable for computing deterministically also the initial nonce. in the non-interactive case. \cref{item:truncate-128} is a valid option for the interactive version.

Hashing multiple variable-length messages into a single challenge (such is the case when hashing $\ctx$, $\tau$) requires care, and multiple approaches have been used in the past. We see three options available:
\begin{enumerate}[label=$(\alph*)$]
  \item Replacing variable-length messages with their hash (i.e. hashing multiple values √† la \emph{Merkle-Damgard}) and computing:
  \[
    \ctx \defeq (\hash(\domsepctx), \curvectx, \generatorsctx, \hash(\idctx))
  \]
  this is currently what proposed in \cite{bip-schnorr} for the specific case of the domain separator (in fact, the authors propose to concatenate the same hash twice to fill an entire SHA-256 block and allow for hash pre-processing).
  \item Encoding the messages in a common format, and hashing the encoded message, i.e.\ computing:
  \( \ctx \defeq \mathsf{encode}(\ctx)\),
  where $\mathsf{encode}$ is a serializer such as e.g.\ JSON encoding, or netstring~\cite{bernstein-netstrings-02}.
  \item Using a protocol framework such as \textsc{Strobe}~\cite{EPRINT:Hamburg17} that builds a sponge construction and can be used for building protocol transcripts. For more information, we direct the reader towards \cite[Section 5.3]{EPRINT:Hamburg17}.
\end{enumerate}

\paragraph{Commitment.} The first step is the generation of uniformly-distributed random element(s) over $\ZZ_p$. As mentioned in \Cref{sec:motivation}, the nonce must be distributed uniformly at random, and even a small bias in the distribution could completely compromise zero-knowledge~\cite{lattice-attack,bleichenbacher,CCS:ANTTY20}.

We propose the construction of a synthetic nonce obtained from hashing statement, context, and secret, together with 8 additional bytes from operating system's entropy:
\[
  r \defeq \hash(\ctx, \stag, \witness, \mathsf{rnd})
\]
where $\mathsf{rnd} \defeq \bin^{64}$ are 64 bits of entropy.
The construction of cryptographically secure source of randomness is a difficult problem, that is particularly challenging on embedded devices such as smart-cards or embedded systems. For those applications for which obtaining a high-quality entropy is challenging, a stateful counter would be sufficient to achieve random $r$.

Hashing the statement and the witness to obtain a commitment was already suggested in previous standards~\cite{rfc6979} in the context of deterministic nonce generation.
While it is widely recognized that having deterministic nonce helps strengthening the concrete security  and mitigates the risks associated to the generation of a commitment, it could on the other hand leak information about the witness used for a proof, when examining consecutive executions of the protocol. This is e.g. the case of a OR-proof that attempts to preserve anonymity.
Consider a ring signature for the ring \(R = (Y_0 , Y_1)\),
and two OR-proofs with the same tag $\stag$.  In a scenario where the nonce is deterministically generated, then the proofs are identical if the same key is used, and different otherwise.

\paragraph{Computing the challenge.}
The challenge is computed as:
\[
  c \defeq \hash(\vec \statement, \vec \commitment, \ctx, \stag)
\]

\paragraph{Response and proof output.} The response is computed using standard field addition and multiplication. The implementation should support batched and short form, as wrappers around the proof transcript as generated by $\prover_2$.
\paragraph{Verification.} The implementation should support two different verification functions, for batched and short verification.
The case of batched verification must include a point verification sub-routing that asserts the statement and commitments are in question. Failure to properly check that a commitment is in the group could lead to subgroup attacks~\cite{EC:VanWie96,C:LimLee97} or invalid curve attacks~\cite{C:BieMeyMul00,RSA:BBPV12}.

If verification fails, an exception should be raised.
If input parsing fails, an exception should be raised.
Otherwise, the verifier outputs $\pctrue$. Optionally, the implementation can choose to return the parsed statement.





\section{Looking Ahead}
To keep this proposal short and open the discussion to a wider community, we purposely left open some topics that could
be interesting for more tight use cases.

\paragraph{Delayed input.}
Despite throughout this work we have assumed that the prover receives as input
instance and witness already when computing the first message, in some $\Sigma$-protocols (c.f. \cref{fig:dlog,fig:dleq,fig:dleq_2})  knowledge of instance and witness is required only in the last round. Therefore,
 the first two messages can be pre-processed obtaining better practical efficiency.
% especially when $\Sigma$-protocols are used inside larger protocols.
 Obviously, this feature relevant only for interactive protocols, which
 %is not very relevant when $\Sigma$-protocols become non-interactive in the random oracle model. However, there are
 might include scenarios requiring deniability or of unconditional soundness.

Unfortunately, the OR composition discussed in \cref{sec:or-comp} affects the possible
delayed-input property of the underlying $\Sigma$-protocols. Consider for instance
the simple OR composition allowing to prove knowledge of at least one out of
two discrete logarithms. Even though the underlying two $\Sigma$-protocols
satisfy the delayed-property, the compound $\Sigma$-protocol obtained through~\cite{C:CraDamSch94}
forces knowledge of the instances already before computing the first message.
Alternative information-theoretic OR compositions have been proposed in~\cite{TCC:CPSSV16},
for practical classes of $\Sigma$-protocols requiring that only one out of two
instances is known when the protocol starts and obtaining a compound delayed-input
$\Sigma$-protocol. Relying on computational (i.e., DDH) assumptions, in~\cite{EC:CPSSV16} it is shown how to generically (i.e., not just two and no further restrictions) compose delayed-input $\Sigma$-protocols obtaining a compound delayed-input $\Sigma$-protocol.

\paragraph{Designated verifier proofs.}
A designated-verifier zero-knowledge proof of knowledge allows the prover to determine an intended receiver for the proof in a way that guarantees that only the specified receiver can actually obtain any conviction about the validity of the prover's claim.
This is important, e.g., in cases where deniability of the communication is important for privacy reasons, and the prover needs to be ensured that the verifier cannot credibly forward the proof to any third party, as he could have simulated proofs with the same distribution himself.
Designated-verifier proofs have been studied profoundly in the academic literature~\cite{EC:JakSakImp96,EC:ChaCou18}.
The most widely known approach is due to Jakobsson et al.~\cite{EC:JakSakImp96}, which achieves the required functionality basically by proving that ``one either knows the secret key, or one is the designated verifier''.
In a nutshell, the idea is that the designated verifier provides the prover with a public key $\statement_{pk}$, and the verifier then proves that he knows a witness $\witness$ for the claimed statement $\statement$ for the given relation $\relation$, or the secret key $\witness_{pk}$ corresponding to $\statement_{pk}$, using the composition techniques from \cref{sec:composition}.

More formally, let $\relation'$ be such that $(\statement_{pk},\witness_{pk})\in\relation'$ if and only if $\witness_{pk}$ is a secret key corresponding to $\statement_{pk}$, e.g., $\relation'=\{(\statement_{pk},\witness_{sk}):\statement=\witness G\}$.
Then, the prover computes a proof for the following relation:
$$
  \relation^{DS} = \{(\statement,\statement_{pk}),(\witness,\witness_{pk}) : (\statement,\witness)\in\relation\lor (\statement_{pk},\witness_{pk})\in\relation'\}\,.
$$
It can now be seen that the prover is now unable to forward the proof to a third party, as he could have generated the proof himself using the secret key.
It it worth noting that it is of crucial importance that the prover's public key comes together with a proof that the prover indeed knows the secret key:
otherwise, by provable sampling the public key at random (e.g., as the hash value of some public string), the prover could credibly claim that he does not know the corresponding key, and thus could not have generated the transcript himself.



\paragraph{Shared proof computation.} Splitting the witness across multiple devices is very appealing from an applied security perspective.
Recently, we saw a number of protocols based on the same template of of \cref{fig:generic} ~\cite{EPRINT:KomGol20,EPRINT:NicRufSeu20}, especially targeting applications in signatures for cryptocurrencies.
Nothing prevents those same techniques to be adopted in the (more general) topic of $\Sigma$-protocols, and we believe the community should have a discussion if interactive proof generation should be supported.
\paragraph{R1CS compatibility.} It is not clear whether it would be beneficial for an API of $\Sigma$-protocols to be aligned with the current zk-proof effort of having a uniform
language for expressing relations (c.f.\ the community reference~\cite[section 3]{zkproof-reference}, and Drevon's proposal~\cite{jr1cs}).
Generally, statements about discrete logarithms are dealt with so-called Camenisch--Stadler notation, and we believe community should come to agree on the acceptable trade-offs for expressing the relation in R1CS language.

\ifanonymous\else
\section*{Acknowledgments}
The authors thank Jan Bobolz, Mary Maller, and Ivan Visconti for their precious reviews and comments during the early stage of this work.
This work has partially been funded by the European Union's Horizon 2020 framework programme under grant agreement no. 830929 (CyberSec4Europe).
\fi
\bibliographystyle{alpha}
\bibliography{cryptobib/abbrev3,cryptobib/crypto,additional}
%
\end{document}
