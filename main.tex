% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
%
\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{amsthm}
% crypto notation
\usepackage[advantage,
            adversary,
            asymptotics,
            complexity,
            ff,
            lambda,
            mm,
            operators,
            primitives,
            probability,
            sets]{cryptocode}

%
\usepackage{mathtools}
%
\usepackage{todonotes}
%
\usepackage[%dvips,
    pdftex,
    pdftitle={Proposal: Sigma-protocols},
    pdfauthor={Stephan Krenn and Michele Orr√π}, pdfpagelabels=true, %linktocpage=true,     backref=page,
    bookmarks,bookmarksopen,bookmarksdepth=3,
    breaklinks,colorlinks,citecolor=blue,linkcolor=blue,urlcolor=blue
   ]{hyperref}
\usepackage[capitalize,nameinlink,sort]{cleveref}
%
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
\renewcommand\UrlFont{\color{blue}\rmfamily}

\usepackage{todonotes}

\input{macros}

\begin{document}

\title{Proposal: $\Sigma$-protocols%
\thanks{This work has partially been funded by the European Union's Horizon 2020 framework programme under grant agreement no. 830929 (CyberSec4Europe).}}
%
\titlerunning{Proposal: $\Sigma$-protocols}

\author{Stephan Krenn\inst{1} \and
        Michele Orr\`u\inst{2}}

\authorrunning{S. Krenn and M. Orr\`u}

\institute{AIT Austrian Institute of Technology, Vienna, Austria \and
           University of California, Berkeley, United States}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
  We submit a proposal for the standardization of non-interactive sigma protocols in prime order groups, allowing for AND and OR composition, either in compact form (challenge, response) or batchable (commitment, response). We propose a selection of elliptic curves and hash functions suitable for implementations, together with a minimal API that should be consistent across implementations.

%\keywords{First keyword  \and Second keyword \and Another keyword.}
\end{abstract}

\section{Introduction}
Sigma protocols are zero-knowledge~\cite{GolMicRac89} proofs of knowledge~\cite{C:BelGol92} without SRS, proven secure in the random oracle model.
Introduced by Schnorr~\cite{JC:Schnorr91} over 30 years ago, they are now widely used  in practice because of their simplicity, maturity, and versatility.

They played an essential component in the building of a number of cryptographic
constructions,
such as anonymous credentials~\cite{CCS:ChaMeiZav14}, password-authenticated key exchange~\cite{jpake},
ring signatures, multi signatures, blind signatures, and more.
Lueks et al.~\cite{zksk}, reported that solely in the years 2018-2019 editions of PETS, ACM CCS, WPES, NDSS,
7 publications use sigma protocols.
Yet, there is no standardized way of implementing them, and as a result a lot of implementations have shared, common pitfalls (cf.\ \cref{sec:motivation}).

We make a first attempt at the standardization of $\Sigma$-protocols by proposing an interface and a language for proving statements about the discrete logarithm of elements in a prime-order cyclic group, targeting specifically groups in elliptic curves. To the best of our knowledge, deployed and implemented sigma protocols rely mostly on the following sub-set of features:

\begin{itemize}
  \item \textbf{Discrete logarithm equality, Diffie-Hellman triples.}
  Proving so-called DLEQ relation is an essential task in some VOPRFs such as~\cite{AC:JarKiaKra14},
  which is currently in process of standardization, thanks to sigma protocols~\cite{cfrg-voprf}.
  DLEQ proofs are also being used by Privacy pass~\cite{PoPETS:DGSTV18}, a lightweight anonymous credential that has been implemented and deployed at scale by Cloudflare, Brave
  Browser, and others.
  There also other works, published in recent academic conferences, that rely on them: Cryptography for \#metoo~\cite{PoPETS:KuyKraRab19}; Solidus~\cite{CCS:CZJKJS17}; ClaimChain~\cite{ClaimChain}.
  \item \textbf{Knowledge of plaintexts, openings of commitments}
  The so-called AND-composition of the dlog relations has been used over a number of protocols,
  including in Algebraic MACs~\cite{CCS:ChaMeiZav14},
  later implemented in Signal~\cite{CCS:ChaPerZav20} and now deployed to millions of users.
  \item \textbf{Proving knowledge of one among multiple discrete logarithms.}
  OR-composition of sigma protocols
  has been used for ring signatures (e.g.~cite{borromean}) and implementing for private transactions in CryptoNote (Monero)~\cite{monero}, Mesh~\cite{PoPETS:AlTGon19}.
  %\item Coconut~\cite{NDSS:SABMD19} with threshold Issuance Selective Disclosure Credentials with Applications to Distributed Ledgers;
  % \item Anonymous Credentials Light~\cite{CCS:BalLys13}
\end{itemize}


All these protocols can be implemented using the API that we propose in section~\cref{sec:composition}.
A request for standardization has also been posted on the \href{https://community.zkproof.org/t/standardizing-sigma-protocols/471/}{zk-proof community} and received a fair amount of interest.

% \subsection{Related Work}

\section{Background and Motivation}
\label{sec:motivation}
So far, there has been little literature meant to help cryptography engineers implement correctly Sigma protocols for arbitrary statements about discrete logs.
Despite Schnorr signatures and zero-knowledge proofs have already been standardized (respectively in \cite{rfc8032} and \cite{rfc8235}), there is still no formal, established way to implement sigma protocols and their composition.
 Additionally, as academic papers focus on proving the security of sigma protocols in generic cyclic groups, the implementation details are often times overlooked, and, as a result, a lot of insecure implementations have been published in the past. To name a few, well-known pitfalls that have led to insecure implementations:
\begin{itemize}
  \item \textbf{Implementation over non-prime order groups could lead to small subgroup attacks}. The cyclic group where proofs are being implemented must be carefully selected. Implementing $\Sigma$-protocol over Weierstrass curves is appealing for its performances and straight-line scalar multiplication formul\ae.
   However, the presence of a small cofactor could be fatal for security.
In 2017, Monero\footnote{\url{https://www.getmonero.org/2017/05/17/disclosure-of-a-major-bug-in-cryptonote-based-currencies.html}} disclosed a vulnerability in Cryptonote-based e-currencies that would allow double-spending
due to the use of curve25519 in place of a prime-order curve.
%\href{https://tools.ietf.org/html/rfc2785#ref-LAW}{RFC2785}, that already provides solutions for avoiding small subgroup attacks)
  \item \textbf{Leakage, partial leakage, or reuse of the commitment is fatal.}
  The first message in a sigma protocol, sometimes called nonce or commitment, must be uniformly distributed in order to preserve zero-knowledge. Re-use of the same nonce~\cite{XX}, or partial leakage allows for the complete recovery of the witness to be proven.
  A blatant instance of this mistake was uncovered in 2010, by the hacker group \texttt{fail0verflow}. They showed how SONY was reusing the same nonce for digitally signing Playstation 3 games\footnote{\url{https://media.ccc.de/v/27c3-4087-en-console_hacking_2010}}.  The member could exploit this to calculate the private key, and create valid signatures.

  \item \textbf{A weak impelmentation of Fiat--Shamir heuristic compromises adaptive security.} The second message in a sigma protocol, sometimes called \emph{challenge}, if computed non-interactives must include non only the commitment, but the full statement and the group description. For instance, if the group generator $G$ is not included in the (EC-DSA) signature, then it is possible to prove statement under a different generator $\alpha G$, for any $\alpha \in \ZZ_p$.
  Similairly, if $X \in \GG$, part of the statement, is not included in the query to the random oracle, it is possible to compute proofs for $\beta X$, for any $\beta \in \ZZ_p$.
  Mistakes of this class were uncovered by Bernhard et al.~\cite{AC:BerPerWar12}, by Haines et al.~\cite{SP:HLPT20}, and by Cortier et al.~\cite{cortier2020}.
  They all showed how some voting systems, respectively Helios,  Scytl-SwissPost, and Belenios,
  implemented incorrectly the Fiat--Shamir heuristic, allowing for tampering of votes.

\end{itemize}
We stress that this is not straightforward:
%Despite Schnorr proofs have been standardized as zero-knowledge proofs (c.f.\ \href{https://tools.ietf.org/html/rfc8235}{RFC8235}) and signatures (c.f.\ ed25519 in \href{https://tools.ietf.org/html/rfc8032}{RFC8032}),
for instance,
the current standardized ed25519 cannot be immediately adapted to a zero-knowledge proof in a secure way,
because of its malleability~\cite[p. 7]{JCEng:BDLSY12},  and the different behavior on the batched and compressed
form\footnote{\url{https://hdevalence.ca/blog/2020-10-04-its-25519am}}.

We hence hereby propose the creation of a working group that includes both recent cryptanalytic insights as well as the
(partial) solutions described in other known standardization documents.
\section{Notation and Terminology}
\label{sec:notation}
%Following [BFS], we consider a deterministic parameter genration algorithm Pgen that returns a group description $\Gamma \defeq (p, G, \GG)$ of a (cyclic) additive, prime order group $\GG = \langle G \rangle$ of order $p$.
For the purpose of this document, the following notation will be used:

\begin{tabular}{r@{\hspace{1em}}p{9cm}}
    $\secpar$ & main security parameter\\
    $\GG = \langle G \rangle$ & cyclic group of prime order $p$ generated by $G$\\
    $\prover,\verifier,\dots$ & potentially randomized algorithms\\
    $x \defeq 1$ & assignment of the value 1 to $x$. \\
    $x\sample\someset$ & assignment of a uniformly random element in $\someset$ to $x$\\
    $x\gets\alg(in)$ & assignment of the ouput of a randomized algorithm $\alg$ on input $in$ to $x$\\
    $\relation$ & binary relation\\
    $\lang(\relation)$ & language induced by a binary relation $\relation$, i.e., $\lang(\relation)=\{y\in\{0,1\}^*:\exists w$ such that $(y,w)\in\relation\}$.\\
    $|y|$ & bitlength of a string\\
    $\NN,\ZZ$ & non-negative natural numbers and integers, respectively
\end{tabular}

\subsection{Formal Definitions}
  In the following we provide the formal definitions required for the remainder of this document.

\subsubsection{$\Sigma$-Protocols}~\\

In the following, we formally describe the class of $\Sigma$-protocols, which covers all protocols considered in the remainder of this document.
 For an in-depth discussion of the underlying theory we refer to Cramer~\cite{cramer97}.
\begin{definition}\label{def:sigma}
  Let $\relation$ be a binary relation and let $(y,w)\in\relation$.
  An interactive two-party protocol specified by algorithms $(\prover_1,\prover_2,\verifier)$ is called a \emph{$\Sigma$-protocol} for $\relation$ with challenge set $\CS$, public input $y$, and private input $w$, if and only if it satisfies the following conditions:
  \begin{description}
    \item[\bf 3-move form:]
      The protocol is of the following form (cf. also~\cref{fig:generic}):
      \begin{itemize}
        \item
          The prover computes $(t,\st) \gets \prover_1(w,y)$ and sends $t$ to the verifier, while keeping $\st$ secret.
        \item
          The verifier draws $c\sample\CS$ and returns it to the prover.
        \item
          The prover computes $s\gets\prover_2(w,y,c,\st)$ and sends $s$ to the verifier.
        \item
          The verifier accepts the protocol run, if and only if $\verifier(y,t,c,s)=\accept$, otherwise it rejects.
      \end{itemize}
      The protocol transcript $(t,c,s)$ is called \emph{accepting} if the verifier accepts the protocol run.
    \item[\bf Completeness:]
      If $(y,w)\in\relation$, then the verifier always outputs $\accept$.
    \item[\bf $t$-special soundness:]
      There exists an efficient algorithm $\extr$ which, given $y$ and $t$ accepting protocol transcripts $(t,c_i,s_i)$ for $i=1,\dots,t$ for public input $y$ with the same first message but pairwise distinct challenges (i.e., $c_i\ne c_j$ for $i\ne j$), returns $w$ such that $(y,w)\in\relation$.
   \minote{$t$ here creates confusion with the commitment}
      \item[\bf Special honest-verifier zero-knowledge:]
      There exists an efficient algorithm $\simulator$, which on input $y$ and a challenge $c\in\CS$, outputs transcripts of the form $(t,c,s)$ whose distribution is indinstinguishable from accepting protocol transcripts generated by real protocol runs on public input $y$ and with challenge $c$.
  \end{description}
    \begin{protocol}{Generic flow of a $\Sigma$-protocol\\[-2.25em]}{fig:generic}{t}
      \begin{tabular}{@{}l@{\hspace{-2em}}c@{\hspace{-2em}}r@{}}
        $\prover(w,y,\relation)$ & & $\verifier(y,\relation)$  \\
        \hline  \\
      % -----------------------------P1-------------------------------
        $ (t,\st) \gets \prover_1(w,y)$\\
        & $\sendr{t}{100}$ \\[2 ex]
      % -----------------------------CHALLENGE-------------------------------
        & & $c \getsr \CS$ \\
        & $\sendl{c}{100}$ & \\[2 ex]
      % -----------------------------P2-------------------------------
        $ s \gets \prover_2(w,y,c,\st)$\\
        & $\sendr{s}{100}$ \\[2 ex]
      % -----------------------------V-------------------------------
        & & $\accept/\reject \gets \verifier(y,t,c,s)$ \\
      \end{tabular}
    \end{protocol}
\end{definition}
Note that $\Sigma$-protocols were originally introduced for the case $t=2$ only.
However, we use the above generalized definition as certain practically relevant optimization techniques require $t>2$.

A $\Sigma$-protocol is said to have \emph{unpredictable commitments} if the probability of generating a collision in the first message is negligible, i.e., if there is a negligible function $\negl$ such that for all $(y,w)\in\relation$ it holds that:
$$
  \Pr[t'=t'' : t'\gets\prover_1(w,y), t''\gets\prover_1(w,y)] \leq \negl\,.
$$

A $\Sigma$-protocol is said to have \emph{unique reponses} if it is infeasible to find two distinct valid responses for a given first message and fixed challenge, i.e., there exist no values $y,t,c,s',s''$ with $s'\ne s''$ such that $\verifier(y,t,c,s')=\verifier(y,t,c,s'')=\accept$.

\subsubsection{Proof Systems and Proofs of Knowledge}~\\

The concept of interactive proofs of knowledge was first mentioned by Goldreich et al.~\cite{STOC:GolMicRac85}, and was then refined by Feige et al.~\cite{STOC:FeiFiaSha87}.
The definitions in the following are due to Bellare and Goldreich~\cite{C:BelGol92}.

Intuitively, a proof system is sound, if it is not possible to make the verifier accept for statements for which no valid witness exists, cf. also~\cite[1.6.2]{zkproof-reference}.
\begin{definition}\label{def:soundness}
  Let $\relation$ be a binary relation, $\sigma:\NN\to[0,1]$ be a function, and let $\prover$ and $\verifier$ specify a probabilistic interactive protocol, where at least $\verifier$ is polynomial time.
  The protocol is called \emph{sound} with \emph{soundness error} $\sigma$, if for every $y\notin\lang(\relation)$, every $w\in\{0,1\}^*$, and every interactive algorithm $\prover^*$, the probability that $\prover^*$ makes $\verifier$ output $\accept$ on common input $y$ is bounded above by $\sigma(|y|)$.
\end{definition}

Informally, an interactive protocol is a proof of knowledge, if every party that is able to make the verifier accept with sufficiently high probability needs to know a valid witness or would be able to compute such a witness, cf. also~\cite[1.6.3]{zkproof-reference}.
\begin{definition}\label{def:pok}
  Let $\relation$ be a binary relation, $\kappa:\NN\to[0,1]$ and let $\prover$ and $\verifier$ specify a probabilistic interactive protocol, where at least $\verifier$ is polynomial time.
  The protocol is then called a \emph{proof of knowledge} for $\relation$ with \emph{knowledge error} $\kappa$, if the folowing conditions are satisfied:
  \begin{description}
    \item[Completeness:]
      If $(y,w)\in\relation$, then the verifier (on input $y$) always outputs $\accept$ in an interaction with the prover (on input $(y,w)$).
    \item[Knowledge soundness:]
      There exists a probabilistic algorithm $\extr$ (the \emph{knowledge extractor}) and a polynomial $\poly$ such that the following holds:
      for every interactive algorithm $\prover^*$ and every $y\in\lang(\relation)$, let $\varepsilon(y,\prover^*)$ be the probability that $\prover^*$ makes $\verifier$ output $\accept$ on common input $y$.
      If $\varepsilon(y,\prover^*)>\kappa(|y|)$, then $\extr$, having rewindable blackbox access to $\prover^*$, outputs $w'$ satisfying $(y,w')\in\relation$ in an expected number of steps bounded by $\frac{\poly[|y|]}{\varepsilon(y,\prover^*)-\kappa(|y|)}$.
  \end{description}
\end{definition}

\section{Constructions for $\Sigma$-Protocols}
\subsection{Basic $\Sigma$-Protocols in Prime-Order Groups}\label{sec:basicsigma}
A basic $\Sigma$-protocol for the relation
$$\relation=\{((y_1,\dots,y_m),(w_1,\dots,w_n)) : (y_1,\dots,y_m)=\varphi(w_1,\dots,w_n)\}$$
 for a group homomorphism $\varphi:\ZZ_p^n\to\GG^m$ is given by the following algorithms:

\begin{enumerate}
  \item\label{item:basic:p1}
    The prover's first algorithm $\prover_1(w,y)$ consists of the following steps:
    \begin{enumerate}
      \item\label{item:basic:p1:randomness}
        It chooses a random element $r_1,\dots,r_n\getsr\ZZ_p$.
      \item
        It then computes $(t_1,\dots,t_m)\gets\varphi(r_1,\dots,r_n)$.
      \item
	The algorithm sets $\st\defeq (r_1,\dots,r_n)$ and $t\defeq(t_1,\dots,t_m)$.
      \item
        It finally outputs outputs $(t,\st)$.
    \end{enumerate}
  \item\label{item:basic:p2}
    The prover's second algorithm $\prover_2(w,y,c,\st)$ proceeds as follows:
    \begin{enumerate}
      \item
        It checks that $c\in\ZZ_u$ and aborts if this is not the case.
      \item
	It then parses $(r_1,\dots,r_n)\defeq \st$ and $(w_1,\dots,w_n)\defeq w$.
      \item
        It computes its output as $s_i\defeq r_i+cw_i$ for $i=1,\dots,n$.
    \end{enumerate}
  \item\label{item:basic:v}
    The verifier's algorithm $\verifier(y,t,c,s)$ proceeds as follow:
    \begin{enumerate}
      \item
      \item\label{item:basic:v:checks}
        It checks that $s_i\in\ZZ_p$ for $i=1,\dots,n$ and $t_j\in\GG$ for $j=1,\dots,m$, and outputs $0$ if this is not the case.
      \item
	It checks whether $(t_1 + cy_1,\dots,t_m + cy_m) = \varphi(s_1,\dots,s_n)$, and outputs $\accept$ if this is the case; otherwise, $\verifier$ outputs $\reject$.
    \end{enumerate}
  \item\label{item:basic:sim}
    The required simulator $\simulator(y,c)$ for a basic $\Sigma$-protocol works as follows:
    \begin{enumerate}
      \item
        It parses $(y_1,\dots,y_m)\defeq y$.
      \item\label{item:basic:sim:s}
        It chooses $s_1,\dots,s_n\getsr\ZZ_p$.
      \item
        It sets $(t_1,\dots,t_m) \defeq \varphi(s_1,\dots,s_n) - c(y_1,\dots,y_m)$.
      \item
        Finally, the algorithm ouputs the simulated transcript by setting $(t,c,s)\defeq((t_1,\dots,t_m),c,(s_1,\dots,s_n)$.
    \end{enumerate}
\end{enumerate}
\minote{here changed a bit $s, r$ from $\GG$ to $\ZZ_p$}

\subsubsection{Proving linear relations among witnesses.}

  While the above protocol allows one to efficiently prove knowledge of a preimage under a homomorphism, many protocols found in the literature require one to prove relations among witnesses.
  Specifically, they require to prove relations like the following:
\begin{align*}
\relation=\{((y_1,\dots,y_m),(w_1,\dots,w_n)) :& (y_1,\dots,y_m)=\varphi(w_1,\dots,w_n) \\
                                               & A(w_1,\dots,w_n) = (b_1,\dots,b_k)\}\,,
\end{align*}
where the matrix $A\in\ZZ_q^{k\times n}$ and vector $(b_1,\dots,b_k)\in\ZZ_p^k$ specify the system of linear equations.

Proving such a relation can easily by achieved by modifying the above protocol as follows:
\begin{itemize}
  \item
    In step \ref{item:basic:p1:randomness}, the prover draws the randomnesses such that they satisfy the system of equations, i.e., such that $A(r_1,\dots,r_n)=(b_1,\dots,b_k)$.
  \item
    In step \ref{item:basic:v:checks}, the verifier additionally checks that $A(s_1,\dots,s_n)=(c+1)(b_1,\dots,b_k)$ and outputs $\reject$ if this is not the case.
  \item
    In step \ref{item:basic:sim:s}, the simulator draws the responses such at they satisfy the verification equations, i.e., such that $A(s_1,\dots,s_n)=(c+1)(b_1,\dots,b_k)$.
\end{itemize}




\subsubsection{Examples}

\paragraph{Example 1 (DLOG).}
Let $\GG$ be a group over an elliptic curve with prime order $p$.
Proving knowledge of the discrete logarithm $w$ of a point $Y$ in base $G$ means proving knowledge of $w\in\ZZ_p$ such that $Y=wG$.
For a description of this proof goal in residue classes, we also refer to~\cite[1.4.1]{zkproof-reference}.

Using the above notation, we have $\varphi:\ZZ_p\to\GG:x\mapsto xG$.
The protocol flow is then as depicted in~\cref{fig:dlog}.
    \begin{protocol}{Proving knowledge of a discrete logarithm.\\[-2.25em]}{fig:dlog}{t}
      \begin{tabular}{@{}l@{\hspace{2em}}c@{\hspace{-3em}}r@{}}
        $\prover\left(w,Y,G\right)$ & & $\verifier\left(Y,G\right)$  \\
        \hline  \\
      % -----------------------------P1-------------------------------
        $ r\getsr\ZZ_p$ & &\\
        $ T \gets rG$ & & \\
        & $\sendr{T}{100}$ \\[2 ex]
      % -----------------------------CHALLENGE-------------------------------
        & & $c \getsr \ZZ_p$ \\
        & $\sendl{c}{100}$ & \\[2 ex]
      % -----------------------------P2-------------------------------
        $ s \defeq r + cw$\\
        & $\sendr{s}{100}$ \\[2 ex]
      % -----------------------------V-------------------------------
        & & Return $\accept$ if and only if \\
        & & $T + cY = sG$ \\
      \end{tabular}
    \end{protocol}

For a given challenge $c\in\ZZ_p$, the simulator chooses $s\getsr\ZZ_p$, and sets $T\gets sG-cY$.
It then outputs the simulated transcript $(T,c,s)$.


\paragraph{Example 2 (DLEQ).}
Let $\GG$ be a group over an elliptic curve with prime order $p$.
Proving equality of the known discrete logarithm $w$ of $Y_1$ in base $G$ and $Y_2$ in base $H$ means proving knowledge of $(w_1,w_2)\in\ZZ_p$ such that $Y_1=w_1G$ and $Y_2=w_2H$, and $w_1=w_2$.

Using the above notation, we have $\varphi:\ZZ_p\to\GG\times\GG:(x_1,x_2)\mapsto (x_1G,x_2H)$.
The linear system of equations $A(w_1,w_2)=b$ is given by $w_1-w_2=0$.
The protocol flow is then as depicted in~\cref{fig:dleq}.
    \begin{protocol}{Proving knowledge of equality of two discrete logarithms.\\[-2.25em]}{fig:dleq}{b}
      \begin{tabular}{@{}l@{\hspace{-4em}}c@{\hspace{-3em}}r@{}}
        $\prover\left( (w_1,w_2),(Y_1,Y_2),(G,H)\right)$ & & $\verifier\left((Y_1,Y_2),(G,H)\right)$  \\
        \hline  \\
      % -----------------------------P1-------------------------------
        $ r_1,r_2\sample\ZZ_p$ such that $r_1-r_2=0$ & &\\
        $ T_1 \gets r_1G$ & & \\
        $ T_2 \gets r_2H$ & & \\
        & $\sendr{T_1,T_2}{100}$ \\[2 ex]
      % -----------------------------CHALLENGE-------------------------------
        & & $c \sample \ZZ_p$ \\
        & $\sendl{c}{100}$ & \\[2 ex]
      % -----------------------------P2-------------------------------
        $ s_1 \gets r_1 + cw_1$\\
        $ s_2 \gets r_2 + cw_2$\\
        & $\sendr{s_1,s_2}{100}$ \\[2 ex]
      % -----------------------------V-------------------------------
        & & Return $\accept$ if and only if \\
        & & $T_1 + cY_1 = s_1G$ \\
        & & $T_2 + cY_2 = s_2H$ \\
        & & and $s_1-s_2=0$.
      \end{tabular}
    \end{protocol}

For a given challenge $c\in\ZZ_p$, the simulator chooses $s_1,s_2\getsr\ZZ_p$ such that $s_1-s_2=0$, and sets $T_1\gets s_1G-cY_1$ and $T_2\gets s_2H - cY_2$.
It then outputs the simulated transcript $((T_1,T_2),c,(s_1,s_2))$.

\paragraph{Example 3 (DLEQ; alternative).}
The same proof goal as in the previous example can also be achieved by considering a slightly different homomorphism, which directly encodes the linear relation, that is $\varphi:\ZZ_p\to\GG\times\GG:x\mapsto (xG,xH)$.
The protocol flow is then as depicted in~\cref{fig:dleq_2}.
    \begin{protocol}{Proving knowledge of equality of two discrete logarithms (alternative).\\[-2.25em]}{fig:dleq_2}{t}
      \begin{tabular}{@{}l@{\hspace{2em}}c@{\hspace{-3em}}r@{}}
        $\prover \left(w,(Y_1,Y_2),(G,H) \right)$ & & $\verifier \left((Y_1,Y_2),(G,H)\right)$  \\
        \hline  \\
      % -----------------------------P1-------------------------------
        $ r\sample\ZZ_p$ & &\\
        $ T_1 \gets rG$ & & \\
        $ T_2 \gets rH$ & & \\
        & $\sendr{T_1,T_2}{100}$ \\[2 ex]
      % -----------------------------CHALLENGE-------------------------------
        & & $c \getsr \ZZ_p$ \\
        & $\sendl{c}{100}$ & \\[2 ex]
      % -----------------------------P2-------------------------------
      % -----------------------------V-------------------------------
        & & Return $\accept$ if and only if \\
        & & $T_1 + cY_1 = sG$ \\
        & & and $T_2 + cY_2 = sH$. \\
      \end{tabular}
    \end{protocol}

For a given challenge $c\in\ZZ_p$, the simulator chooses $s\getsr\ZZ_p$, and sets $T_1\gets sG-cY_1$ and $T_2\gets sH - cY_2$.
It then outputs the simulated transcript $((T_1,T_2),c,s)$.

\paragraph{Example 4 (REP).}
Let $\GG$ be a group over an elliptic curve of prime order $p$.
Proving knowledge of a valid opening of a Pedersen commitment means proving knowledge of $w_1,w_2\in\ZZ_p$ such that $Y=w_1G + w_2H$.

Using the above notation, we have $\varphi:\ZZ_p\times\ZZ_p\to\GG:(x_1,x_2)\mapsto x_1G + x_2H$.
The protocol flow is then as depicted in~\cref{fig:rep}.
    \begin{protocol}{Proving knowledge of representation.\\[-2.25em]}{fig:rep}{h!}
      \begin{tabular}{@{}l@{\hspace{2em}}c@{\hspace{-3em}}r@{}}
        $\prover \left( (w_1,w_2),Y,(G,H)\right)$ & & $\verifier \left(Y,(G,H)\right)$  \\
        \hline  \\
      % -----------------------------P1-------------------------------
        $ r_1\getsr\ZZ_p$ & &\\
        $ r_2\getsr\ZZ_p$ & &\\
        $ T \gets r_1G + r_2H$ & & \\
        & $\sendr{T}{100}$ \\[2 ex]
      % -----------------------------CHALLENGE-------------------------------
        & & $c \getsr \ZZ_p$ \\
        & $\sendl{c}{100}$ & \\[2 ex]
      % -----------------------------P2-------------------------------
        $ s_1 \defeq r_1 + cw_1$\\
        $ s_2 \defeq r_2 + cw_2$\\
        & $\sendr{s_1,s_2}{100}$ \\[2 ex]
      % -----------------------------V-------------------------------
        & & Return $\accept$ if and only if \\
        & & $T + cY = s_1G + s_2H$ \\
      \end{tabular}
    \end{protocol}

For a given challenge $c\in\ZZ_p$, the simulator chooses $s_1,s_2\getsr\ZZ_p$, and sets $T\gets s_1G + s_2H -cY$.
It then outputs the simulated transcript $(T,c,(s_1,s_2))$.

\paragraph{Example 5 (DH).}
Let $\GG$ be a group over an elliptic curve with prime order $p$.
Proving knowledge of the exponents of a valid Diffie-Hellman triple means proving knowledge of $w_1,w_2\in\ZZ_p$ such that $Y_1=w_1G$, $Y_2=w_2G$, and $Y_3=w_1 w_2 G$.
Yet, the mapping $\ZZ_p^2\to\GG^3:(x_1,x_2)\mapsto (x_1G,x_2G,x_1x_2G)$ is not a homomorphism, and consequently the basic protocol presented before cannot be deployed directly.
However, the required multiplicative relation can be proven by observing that the proof goal is equivalent to $Y_1=w_1G$, $Y_2=w_2G$, and $Y_3=w_2Y_1$, leading the homomorphism $\varphi:\ZZ_p^2\to\GG^3:(x_1,x_2)\mapsto(x_1G,x_2G,x_2Y_1)$.

The protocol flow is then as depicted in~\cref{fig:dh}.
    \begin{protocol}{Proving knowledge of representation.\\[-2.25em]}{fig:dh}{t}
      \begin{tabular}{@{}l@{\hspace{-3em}}c@{\hspace{-2em}}r@{}}
        $\prover\left( (w_1,w_2),(Y_1,Y_2,Y_3),G)\right)$ & & $\verifier\left((Y_1,Y_2,Y_3),G \right)$  \\
        \hline  \\
      % -----------------------------P1-------------------------------
        $ r_1\getsr\ZZ_p$ & &\\
        $ r_2\getsr\ZZ_p$ & &\\
        $ T_1 \gets r_1G$ & & \\
        $ T_2 \gets r_2G$ & & \\
        $ T_3 \gets r_2Y_1$ & & \\
        & $\sendr{T_1,T_2,T_3}{100}$ \\[2 ex]
      % -----------------------------CHALLENGE-------------------------------
        & & $c \getsr \ZZ_p$ \\
        & $\sendl{c}{100}$ & \\[2 ex]
      % -----------------------------P2-------------------------------
        $ s_1 \gets r_1 + cw_1$\\
        $ s_2 \gets r_2 + cw_2$\\
        & $\sendr{s_1,s_2}{100}$ \\[2 ex]
      % -----------------------------V-------------------------------
        & & Return $\accept$ if and only if \\
        & & $T_1 + cY_1 = s_1G$ \\
        & & $T_2 + cY_2 = s_2G$ \\
        & & and $T_3 + cY_3 = s_2Y_1$ \\
      \end{tabular}
    \end{protocol}

For a given challenge $c\in\ZZ_p$, the simulator chooses $s_1,s_2\getsr\ZZ_p$, and sets $T_1\gets s_1G -cY_1$, $T_2\gets s_2G-cY_2$, and $T_3\gets s_2Y_1-cY_3$.
It then outputs the simulated transcript $((T_1,T_2,T_3),c,(s_1,s_2))$.

As shown in this example, and in contrast to linear relations, multiplicative relations among witnesses typically require a reformulation of the proof goal in order to be compatible with the generic protocol presented above.
We refer, e.g., to Krenn~\cite{krenn12} for generic techniques.

\subsection{Composition of $\Sigma$-Protocols}\label{sec:composition}
  In this section, we recap composition techniques of $\Sigma$-protocols.
  Specifically, we define mechanisms for proving knowledge of multiple independent witnesses (``AND-composition''), and for proving knowledge for one out of a set of witnesses (``OR-composition'').
  Without loss of generality, the techniques presented in the following focus on the composition of two protocols;
  proving knowledge of more than two witnesses, or for out of a larger set of witnesses, can directly be achieved by iteratively deploying the techniques.

  For the rest of this section, we let $(\prover_1^0,\prover_2^0,\verifier^0)$ and $(\prover_1^1,\prover_2^1,\verifier^1)$ be the specifications of two $\Sigma$-protocols for two relations $\relation^0$ and $\relation^1$, and let $\simulator^0$ and $\simulator^1$ be their simulators.

  Furthermore, we assume that the challenge sets are given by $\ZZ_{u^0}$ and $\ZZ_{u^1}$, respectively.
  We let $u=\min(u^0,u^1)$.


\subsubsection{AND Composition.}
  In the following we explain how to construct a $\Sigma$-protocol proving knowledge of multiple independent witnesses.
  That is, the algorithms specified below constitute a $\Sigma$-protocol for the following relation:
$$
  \relation^\land = \left\{ ((y^0,y^1),(w^0,w^1) : (y^0,w^0)\in \relation^0 ~\land~ (y^1,w^1)\in\relation^1\right\}\,.
$$


\begin{enumerate}
  \item
    The prover's first algorithm $\prover_1(w,y)$ consists of the following steps:
    \begin{enumerate}
      \item
        The algorithm parses $(w^0,w^1)\defeq w$ and $(y^0,y^1)\defeq y$.
      \item
        It computes $(t^0,\st^0)\gets\prover_1^0(y^0,w^0)$ and $(t^1,\st^1)\gets\prover_1^1(y^1,w^1)$.
      \item
	The algorithm outputs $(t,\st) \defeq ((t^0,t^1),(\st^0,\st^1))$.
    \end{enumerate}
  \item
    The prover's second algorithm $\prover_2(w,y,c,\st)$ proceeds as follows:
    \begin{enumerate}
      \item
        It checks that $c\in\ZZ_u$ and aborts if this is not the case.
      \item
	It parses $(\st^0,\st^1)\defeq \st$
      \item
        It computes $s^0\gets\prover_2^0(w^0,y^0,c,\st^0)$ and $s^1\gets\prover_2^1(w^1,y^1,c,\st^1)$.
      \item
        It outputs $s\defeq(s^0,s^1)$.
    \end{enumerate}
  \item
    The verifier's algorithm $\verifier(y,t,c,s)$ proceeds as follow:
    \begin{enumerate}
      \item
        It  parses $(s^0,s^1)\defeq s$.
      \item
	The algorithm outputs $\verifier^0(y^0,t^0,c,s^0)\land\verifier^1(y^1,t^1,c,s^1)$.
    \end{enumerate}
  \item
    The required simulator $\simulator(y,c)$ works as follows:
    \begin{enumerate}
      \item
        It parses $(y^0,y^1)\defeq s$.
      \item
        It chooses $c\in\ZZ_u$.
      \item
        It computes $(t^0,c,s^0)\gets\simulator^0(y^0,c)$ and $(t^1,c,s^1)\gets\simulator^1(y^1,c)$.
      \item
        Finally, the algorithm then outputs $(t,c,s)\defeq((t^0,t^1),c,(s^0,s^1))$.
    \end{enumerate}
\end{enumerate}


\subsubsection{OR Composition.}
  In the following we explain how to construct a $\Sigma$-protocol proving knowledge of one out of a set of witnesses.
  That is, the algorithms specified below constitute a $\Sigma$-protocol for the following relation:
$$
  \relation^\lor = \left\{ ((y^0,y^1),(w^0,w^1) : (y^0,w^0)\in \relation^0 ~\lor~ (y^1,w^1)\in\relation^1\right\}\,.
$$

  In the following protocol specification, let $j$ be such that $w^j$ is known to the prover, whereas without loss of generality $w^{1-j}$ is assumed to be unknown to the prover.
\begin{enumerate}
  \item
    The prover's first algorithm $\prover_1(w,y)$ consists of the following steps:
    \begin{enumerate}
      \item
        The algorithm parses $(w^0,w^1)\defeq w$ and $(y^0,y^1)\defeq y$, where $w^{1-j}=\bot$.
      \item
        It computes $(t^j,\st^j)\getsr\prover_1^j(y^j,w^j)$.
      \item
        It computes a simulated transcript for the unknown witness by choosing $c^{1-j}\getsr\ZZ_u$ and setting $(t^{1-j},c^{1-j},s^{1-j})\getsr\simulator^{1-j}(y^{1-j},c^{1-j})$.
      \item
	The algorithm outputs $(t,\st) \defeq ((t^0,t^1),(\st^j,c^{1-j},s^{1-j}))$.
    \end{enumerate}
  \item
    The prover's second algorithm $\prover_2(w,y,c,\st)$ proceeds as follows:
    \begin{enumerate}
      \item
        It checks that $c\in\ZZ_p$ and aborts if this is not the case.
      \item
	It parses $\st\defeq(\st^j,c^{1-j},s^{1-j})$.
      \item
        It computes $c^j\defeq c-c^{1-j}$, and sets $s^j\gets\prover_2^j(w^j,y^j,c^j,\st^j)$.
      \item
        It computes $s^0\gets\prover_2^0(w^0,y^0,c,\st^0)$ and $s^1\gets\prover_2^1(w^1,y^1,c,\st^1)$.
      \item
        It outputs $s\defeq(s^0,s^1,c^0)$.
    \end{enumerate}
  \item
    The verifier's algorithm $\verifier(y,t,c,s)$ proceeds as follow:
    \begin{enumerate}
      \item
        It  parses $(s^0,s^1,c^0)\defeq s$.
      \item
        It sets $c^1\defeq c-c^0$.
      \item
	The algorithm outputs $\verifier^0(y^0,t^0,c^0,s^0)\land\verifier^1(y^1,t^1,c^1,s^1)$.
    \end{enumerate}
  \item
    The required simulator $\simulator(y,c)$ works as follows:
    \begin{enumerate}
      \item
        It parses $(y^0,y^1)\defeq y$.
      \item
        It chooses a random $c^0$ in $\ZZ_u$ and computes $c^1\defeq c-c^0$.
      \item
        It then computes $(t^0,c^0,s^0)\gets\simulator^0(y^0,c^0)$ and $(t^1,c^1,s^1)\gets\simulator^1(y^1,c^1)$.
      \item
        Finally, the algorithm then outputs $(t,c,s)\defeq((t^0,t^1),c,(s^0,s^1,c^0))$.
    \end{enumerate}
\end{enumerate}


\subsection{Achieving Non-Interactivity -- The Fiat-Shamir Transform}
All protocols describes so far require three messages being exchanged between the prover and the verifier.
However, communication rounds are often considered expensive from an efficiency point of view, and for many applications interactivy is not desirable.

We describe two variants for achieving non-interactivity. Both variants require identical computations on the prover's side.
The first variant allows for efficient batching, but requires point validation and (depending on the hash function, or the elliptic curve chosen) might lead
slightly larger proof sizes. The second variant requires no point validation and only has the hash value.

The constructions are based on the seminal work of Fiat and Shamir~\cite{C:FiaSha86} and subsequent work, e.g., by Bernhard et al.~\cite{AC:BerPerWar12}.
The underlying idea of this so-called Fiat-Shamir transform is to simulate the verifier's random challenge by means of a random oracle, depending on the first message computed by the prover.
More precisely, the challenge is computed as $c\defeq\hash(t,y,\ctx)$, where $t$ is the prover's first message from the $\Sigma$-protocol, and $y$ is the public image for which knowledge of a witness is proven.
The context string $\ctx$ contains application-specific information, such as:
\begin{itemize}
  \item
    a full description of the algebraic setting and proof goal (e.g., group descriptions, generators, etc.) to achieve non-malleability;
  \item
    local context information (e.g., session identifiers of higher level protocols) to avoid replay-attacks, or shared randomness or a timestamp to guarantee freshness of the proof.
\end{itemize}

\subsubsection{Batchable form}


\begin{enumerate}
  \item
    The prover's algorithm $\prover'(y,w,\ctx)$ works as follows:
    \begin{enumerate}
      \item
        The algorithm first computes $(t,\st)\gets\prover_1(y,w)$.
      \item
        It computes the challenge by setting $c\defeq\hash(t,y,\ctx)$.
      \item
        The algorithm defines $s\gets\prover_2(y,w,c,\st)$.
      \item
        The algorithm outputs $(t,s)$.
    \end{enumerate}
  \item
    The verifier's algorithm $\verifier'(y,t,s,\ctx)$ works as follows:
    \begin{enumerate}
      \item
        It recomputes the challenge as $c\gets\hash(t,y,\ctx)$.
      \item
        It outputs whatever $\verifier(y,t,c,s)$ outputs.
    \end{enumerate}
\end{enumerate}

\subsubsection{Short form}
\begin{enumerate}
  \item
    The prover's algorithm $\prover''(y,w,\ctx)$ works as follows:
    \begin{enumerate}
      \item
        The algorithm first computes $(t,\st)\defeq\prover_1(y,w)$.
      \item
        It computes the challenge by setting $c\defeq\hash(t,y,\ctx)$.
      \item
        The algorithm defines $s\gets\prover_2(y,w,c,\st)$.
      \item
        The algorithm outputs $(c,s)$.
    \end{enumerate}
  \item
    The verifier's algorithm $\verifier''(y,c,s,\ctx)$ works as follows:
    \begin{enumerate}
      \item\label{item:fslong:v:recomputet}
        The algorithm recomputes the first message $t$ by running the appropriate steps of the simulator $\simulator$.
      \item
        The algorithm checks that $c=\hash(t,y,\ctx)$ and rejects if this is not the case.
    \end{enumerate}
\end{enumerate}

More specifically, when calling $\simulator$ in~\cref{item:fslong:v:recomputet}, the verifier does not draw the response $s$ at random, as is the case in all the protocols introduced before;
instead it uses the value specified in the proof.

\section{Security Considerations}

In the following, we give a concise overview of the most important security guarantees provided by the constructions presented above.

Firstly, all the protocols presented in the previous section are $\Sigma$-protocols according to~\cref{def:sigma}.
\begin{theorem}
  If $\GG$ is a cyclic group of prime order $p$, $\varphi:\ZZ_p^n\to\GG^m$ is a group homomorphism, and $u\leq p$, then the basic protocol in~\cref{sec:basicsigma} is a $\Sigma$-protocol with simulator $\simulator$.

  If $\varphi$ is non-trivial, the protocol has unpredictable commitments.
  Finally, if $\varphi(x')\ne\varphi(x'')$ for all $x'\ne x''$, the protocol has unique responses.
\end{theorem}

\begin{theorem}
  If, for $i=0,1$, $(\prover_1^i,\prover_2^i,\verifier^i)$ is a $\Sigma$-protocol for relation $\relation^i$ with challenge set $\ZZ_{u^i}$ and simulator $\simulator^i$, then the protocols specified in Section~\ref{sec:composition} are $\Sigma$-protocol with challenge set $\ZZ_u$ and simulator $\simulator$ for relation $\relation^\land$ and $\relation^\lor$, respectively.

  If at least one of the composed protocols has unpredictable commitments, then so has the protocol for $\relation^\land$.
  If both protocols have unique responses, then so has the protocol for $\relation^\land$.
%  If all composed protocols have unique responses, then so has the composed protocol.
\end{theorem}


In a nutshell, $\Sigma$-protocols are honest-verifier zero-knowledge proofs of knowledge, whose security guarantees are maintained under the Fiat-Shamir transform at least against classical attackers.









For full details and proofs, we refer to the original literature.
\minote{citation needed}
\begin{itemize}
  \item
    If $\prover_1,\prover_2,\verifier$ specify a $\Sigma$-protocol for $\relation$ according to~\cref{def:sigma}, then they also specify an honest-verifier zero-knowledge proof of knowledge with soundness error $\sigma=1/m$ and knowledge error $\kappa=1/m$ for $\relation$.

For formal proofs we refer, e.g., to Damg\r{a}rd~\cite{damgard04}.
  \item
    If a $\Sigma$-protocol is complete and has unpredictable commitments, then the Fiat-Shamir transform is {\bf complete}.

    For a proof we refer to Unruh~\cite{AC:Unruh17}, which also gives a surprising counter-example in case that commitments are not unpredictable.
  \item
    If a $\Sigma$-protocol is honest-verifier zero-knowledge and has unpredictable commitments, then the Fiat-Shamir transform yields a {\bf zero-knowledge} protocol in the random oracle model.

    For a proof we refer to Faust et al.~\cite{INDOCRYPT:FKMV12} and Unruh~\cite{AC:Unruh17}.
  \item
    If a $\Sigma$-protocol has a negligible soundness error, then the Fiat-Shamir transform is {\bf sound} according to~\cref{def:soundness}.
    This security guarantee also holds against quantum attackers.

    For a proof we refer to Pointcheval and Stern~\cite{JC:PoiSte00} and Unruh~\cite{AC:Unruh17}.
  \item
    If a $\Sigma$-protocol has a negligible soundness error, then the Fiat-Shamir transform is {\bf weakly simulation-sound} according to Definition~\ref{def:xxx}.
    If the protocol additionally has unique responses, then the Fiat-Shamir transform is {\bf strongly simulation-sound} according to Definition~\ref{def:xxx}.
    These security guarantees also holds against quantum attackers.

    For a proof we refer to Unruh~\cite{AC:Unruh17} and Faust et al.~\cite{INDOCRYPT:FKMV12}.
  \item
    If a $\Sigma$-protocol has a negligible soundness error, then the Fiat-Shamir transform is {\bf simulation-sound extractable} according to Definition~\ref{def:xxx}.

    For a proof we refer to Bernhard et al.~\cite{AC:BerPerWar12}.
\end{itemize}

\section{Instantiation }

\begin{table}[t]
  \caption{Summary of implementations, along with features supported.
  \label{table:implementations}}
  \centering
\begin{tabular}{rccc}
  Project & AND-composition & OR-composition & last activity \\
  \hline
  \emph{SCAPI}~\cite{scapi}\\
  zkp~\cite{zkp}\\
  zksk~\cite{zksk}\\
  Emmy\\
  Helios \\
  \hline
\end{tabular}
\end{table}

In this section, we consider the concrete security of $\Sigma$-protocols, and illustrate the main points that should be consider when implementing them.
In \cref{table:implementations}, we report the implementations that we are currently aware of, and that we believe should be considered when issuing guidelines for a standard.
This table is greatly inspired from the remarkable bibliographic work of Lueks et al.~\cite{zksk}.
\paragraph{Choice of a group.} We advise for the use of prime-order elliptic curves of either 256 or 512 bits of security, depending on the desired security of the upper layers in the protocol\footnote{For instance, proving a DH relation with one fixed group element such as a public key, might expose the protocol to cryptanalytic attacks such as Brown-Gallant~\cite{EPRINT:BroGal04} and Cheon‚Äôs attack~\cite{EC:Cheon06}. We consider these attacks out of scope for this standardization effort, and believe this analysis should be deferred to the concrete security study of the larger protocol.}.
Concretely, we see fit standardized curves such as NIST curves p-521 and p-256~\cite{fips2}, secp256k1~\cite{SECG}, or standardized prime-order group abstractions over non prime-order groups, such as Decaf or Ristretto~\cite{cfrg-ristretto-decaf}.

We think pairing-friendly curves, such as BLS12-381~\cite{bls12}, should also be considered for inclusion under relevant assumptions for bilinear groups, such as XDH when dealing with DH triples\footnote{We are aware of the threats reported in
\url{https://safecurves.cr.yp.to/}.
Yet, it's not clear what should be the alternatives, and if dropping their support would hinder adoption.
}.
\minote{how seriously should we consider safe curves and replaces the curves I suggest?}
We note that the exists already standards for removing small cofactors in elliptic curves~\cite{rfc2785}.
 However we believe that this should be implemented as an abstraction layer over the protocol.
\minote{chek if standards works well}

\paragraph{Commitment.} The first step is the generation of a uniformly-distributed random element over $\ZZ_p$. As mentioned in \Cref{sec:motivation}, the nonce must be distributed uniformly at random, and even a small bias in the distribution could completely compromise zero-knowledge~\cite{XX}.

We propose the construction of a synthetic nonce obtained from hashing statement, context, and secret, together with 32 additional bytes from operating system's entropy.

The construction of cryptographically secure source of randomness is a difficult problem, that is particularly challenging on embedded devices such as smart-cards or embedded systems. For those applications for which obtaining a high number of entropy is challenging, we propose the use of a stateful counter.
Hashing the statement and the witness to obtain a commitment was already suggested in previous standards~\cite{rfc6979} in the context of deterministic nonce generation.
While it is widely recognized that having deterministic nonce helps strengthening the concrete security  and mitigates the risks associated to the generation of a commitment, it could on the other hand leak information about the witness used for a proof, when examining consecutive executions of the protocol. This is e.g. the case of a OR-proof that attempts to preserve anonymity.

\paragraph{Computing the challenge.} In the non-interactive $\Sigma$-protocols, the challenge is the image of a cryptographically-secure hash function,
given as input the commitment, the context, and the tag.

The hash function can be either blake2~\cite{XX}, SHA-256, or SHA3~\cite{XX} truncated to the first 128 buts, or a more structured hash into a prime $p$.
The first provides an efficient way of hashing into the curve, but collision resistance might be impacted for e.g. post-quantum security.
The latter guarantees more seucirty, but requires a more involved implementation.
We direct the curious reader to~\cite{XX} for further information.

\minote{what is the post-quantum impact of 128-bits truncated hash?}
The context is composed of: domain separator, any information provided to the external protocol.
\minote{mention concatenation could lead to attacks. zkp uses strobe to get around it.}

\paragraph{Response and proof output.} The response is computed using standard field addition and multiplication.
\paragraph{Verification.} The \verb|proof| object should support two different verification functions, for batched and short verification.
If verification fails, an exception should be raised.
If input parsing fails, an exception should be raised.
Otherwise, the verifier outputs $\pctrue$.





\section{Looking Ahead}
To keep this proposal short and open the discussion to a wider community, we purposely left open some topics that could
be interesting for more tight use cases.
\minote{designated verifier proofs.\\
 either or proof I'm you or the staement is true + commitment discrete log}
\minote{delayed input}
\paragraph{Batched verification.}
\minote{Shared proof computation\\
check multisignatures and add the new problem of computing proofs with devices that share different keys}
\paragraph{R1CS compatibility.} It is not clear whether it would be beneficial for an API of $\Sigma$-protocols to be aligned with the current zk-proof effort of having a uniform
language for expressing relations (c.f.\ the community reference~\cite[section 3]{zkproof-reference}, and Drevon's proposal~\cite{jr1cs}).
Generally, statements about discrete logarithms are dealt with so-called Camenisch--Stadler notation, and it is not clear what would be the computational burden of expressing the relation in R1CS language.

\bibliographystyle{alpha}
\bibliography{cryptobib/abbrev3,cryptobib/crypto,additional}
%
\end{document}
