% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{amsthm}
% crypto notation
\usepackage[advantage,
            adversary,
            asymptotics,
            complexity,
            ff,
            lambda,
            mm,
            operators,
            primitives,
            probability,
            sets]{cryptocode}

%
\usepackage{mathtools}
%
\usepackage{todonotes}
%
\usepackage[%dvips,
    pdftex,
    pdftitle={Proposal: Sigma-protocols},
    pdfauthor={Stephan Krenn and Michele Orr√π}, pdfpagelabels=true, %linktocpage=true,     backref=page,
    bookmarks,bookmarksopen,bookmarksdepth=3,
    breaklinks,colorlinks,citecolor=blue,linkcolor=blue
   ]{hyperref}
\usepackage[capitalize,nameinlink,sort]{cleveref}
%
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
\renewcommand\UrlFont{\color{blue}\rmfamily}

\usepackage{todonotes}

\input{macros}

\begin{document}

\title{Proposal: $\Sigma$-protocols%
\thanks{This work has partially been funded by the European Union's Horizon 2020 framework programme under grant agreement no. 830929 (CyberSec4Europe).}}
%
\titlerunning{Proposal: $\Sigma$-protocols}

\author{Stephan Krenn\and
        Michele Orr\`u}

\authorrunning{S. Krenn and M. Orr\`u}

\institute{AIT Austrian Institute of Technology, Vienna, Austria \and
           University of California, Berkeley, United States}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
  We propose a standardization document for sigma protocols in prime order groups, allowing for AND and OR composition, either in compact form (challenge, response) or batchable (commitment, response). We propose a selection of elliptic curves and hash functions suitable for implementations, together with a minimal API that should be consistent across implementations.
  \minote{Add non-interactive}

\keywords{First keyword  \and Second keyword \and Another keyword.}
\end{abstract}

\section{Introduction}

Sigma protocols are simple, mature, and powerful zero-knowledge proof systems.
This problem ahs already been posted on the zk-proof community\footnote{\url{https://community.zkproof.org/t/standardizing-sigma-protocols/471/}} and received a fair amount of interest.

\subsection{Related Work}

\section{Background and Motivation}
\label{sec:motivation}
So far, there has been little literature meant to help cryptography engineers implement correctly Sigma protocols.
Despite Schnorr proofs have been standardized as zero-knowledge proofs (c.f.\ \href{https://tools.ietf.org/html/rfc8235}{RFC8235}) and signatures (c.f.\ ed25519 in \href{https://tools.ietf.org/html/rfc8032}{RFC8032}),
%a
 it is not yet clear what is the correct way to implement a Sigma protocol for a logical statement on the discrete logarithm of a $n$ group elements.
 \minote{reformulate? say something "on the other hand?"}
 For instance, the current standardized ed25519 cannot be trivially adapted to a zero-knowledge proof in a secure way, because of its malleability~\cite[p. 7]{JCEng:BDLSY1},  and the different behavior on the batched and compressed form\footnote{\url{https://hdevalence.ca/blog/2020-10-04-its-25519am}}.
As academic papers focus on proving the security of sigma protocols in generic prime-order groups, the implementation details are often times overlooked in academic papers and, as a result, a lot of insecure implementations have been published in the past. To name a few examples:
\begin{itemize}
\item \textbf{Leakage, partial leakage, or reuse of the nonce is fatal.}
In 2010, the hacker group \texttt{fail0verflow} showed that SONY was reusing the same nonce for digitally signing Playstation 3 games\footnote{\url{https://media.ccc.de/v/27c3-4087-en-console_hacking_2010}}. The member could exploit this to calculate the private key, and create valid signatures.
\minote{this was on ecdsa}
\item \textbf{A weak impelmentation of Fiat--Shamir heuristic compromises adaptive security.} In 2016, Bernhard et al.~\cite{??} demonstrated how Helios, a platform for e-voting, calculated the challenge using the Fiat--Shamir heuristic, without including the generator, allowing for tampering of votes.

\item \textbf{Implementation over non-prime order groups could lead to small subgroup attacks}. In 2017, Monero\footnote{\url{https://www.getmonero.org/2017/05/17/disclosure-of-a-major-bug-in-cryptonote-based-currencies.html}} disclosed a vulnerability in Cryptonote-based e-currencies that would allow double-spending.\href{https://tools.ietf.org/html/rfc2785#ref-LAW}{RFC2785}, that already provides solutions for avoiding small subgroup attacks),
\end{itemize}

\section{Notation and Terminology}

\section{Constructions for $\Sigma$-Protocols}
\subsection{Basic $\Sigma$-Protocols in Prime-Order Groups}
A basic $\Sigma$-protocol to prove knowledge of a preimage $x$ of $y$ under a homomorphism $\varphi:\GG\to\HH$ consists of three messages being exchanged:

\begin{enumerate}
  \item
    In a first step, the prover $\prover$ chooses a random element $r\getsr\GG$ and computes $t\gets\varphi(r)$.
	It sends $t$ to the verifier $\verifier$.
  \item
    Next, $\verifier$ chooses $c\getsr\CC$ and sends $c$ back to the prover.
  \item
    The prover checks that $c\in\CC$ and aborts if this is not the case.
	It computes its response as $s\gets r+cx$, which it sends to the verifier.
  \item
    The verifier checks that $s\in\GG$ and $t\in\HH$, and outputs $0$ if this is not the case.
	It then checks whether $t + cy = \varphi(s)$, and outputs $1$ if this is the case; otherwise, $\verifier$ outputs $0$.
\end{enumerate}

\begin{theorem}
  If $\HH$ is a cyclic group of prime order $q$, $\varphi:\GG\to\HH$ is a group homomorphism, and $\CC=\ZZ_m$ for some $m\leq q$, then the above $\Sigma$-protocol is an honest-verifier zero-knowledge proof of knowledge for the relation $y=\varphi(x)$.
\end{theorem}

\subsection{Composition of $\Sigma$-Protocols}
\subsubsection{AND Composition}

\subsubsection{OR Composition}

\subsection{Achieving Non-Interactivity - The Fiat-Shamir Transform}


\section{Security Considerations}

Papers with the seucurity proofs + limitation
\minote{mention simulation extractability? XXX}
\minote{mention post-quantum security guarantees?}

\section{Implementation}
Implementations already there + APi design + representation + other subleties (check if a point is in the group etc.)

\subsection{Pre-existing implementations}
\paragraph{SCAPI.}
\paragraph{zkp.}
\paragraph{zksk.}
\paragraph{Emmy}

\subsection{A candidate API design}

\paragraph{Key Generation.}

\paragraph{Nonce Generation.} The first stem in the generation of a sigma proof is the generation of a cryptographically secure nonce. As mentioned in \Cref{sec:motivation}, the nonce must be distributed uniformly at random, and even a small bias in the distribution could completely compromise zero-knowledge.
The construction of cryptographically secure source of randomness is a difficult problem, that is particularly challenging on embedded devices such as smart-cards or embedded systems.
For this reason, we propose the generation of a synthetic nonce obtained from hashing the statement and the secret together, as already suggested in previous standards \href{https://tools.ietf.org/html/rfc6979}{RFC6979}.

\minote{XXX. what do we do for ring signatures that repeat the same statement twice? suggest to add a counter or a new random entry in the message?}

\paragraph{Computing the challenge.}

\section{Open Problems}
\minote{check multisignatures and add the new problem of computing proofs with devices that share different keys}
\bibliographystyle{splncs04}
\bibliography{cryptobib/abbrev3,cryptobib/crypto}
%
\end{document}
