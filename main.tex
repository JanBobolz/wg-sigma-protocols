% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%



\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{amsthm}
% crypto notation
\usepackage[advantage,
            adversary,
            asymptotics,
            complexity,
            ff,
            lambda,
            mm,
            operators,
            primitives,
            probability,
            sets]{cryptocode}

%
\usepackage{mathtools}
%
\usepackage{todonotes}
%
\usepackage[%dvips,
    pdftex,
    pdftitle={Proposal: Sigma-protocols},
    pdfauthor={Stephan Krenn and Michele Orr√π}, pdfpagelabels=true, %linktocpage=true,     backref=page,
    bookmarks,bookmarksopen,bookmarksdepth=3,
    breaklinks,colorlinks,citecolor=blue,linkcolor=blue
   ]{hyperref}
\usepackage[capitalize,nameinlink,sort]{cleveref}
%
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
\renewcommand\UrlFont{\color{blue}\rmfamily}

\usepackage{todonotes}

\input{macros}

\begin{document}

\title{Proposal: $\Sigma$-protocols%
\thanks{This work has partially been funded by the European Union's Horizon 2020 framework programme under grant agreement no. 830929 (CyberSec4Europe).}}
%
\titlerunning{Proposal: $\Sigma$-protocols}

\author{Stephan Krenn\and
        Michele Orr\`u}

\authorrunning{S. Krenn and M. Orr\`u}

\institute{AIT Austrian Institute of Technology, Vienna, Austria \and
           University of California, Berkeley, United States}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
  We propose a standardization document for sigma protocols in prime order groups, allowing for AND and OR composition, either in compact form (challenge, response) or batchable (commitment, response). We propose a selection of elliptic curves and hash functions suitable for implementations, together with a minimal API that should be consistent across implementations.
  \minote{Add non-interactive}

\keywords{First keyword  \and Second keyword \and Another keyword.}
\end{abstract}

\section{Introduction}

Sigma protocols are simple, mature, and powerful zero-knowledge proof systems.
This problem ahs already been posted on the zk-proof community\footnote{\url{https://community.zkproof.org/t/standardizing-sigma-protocols/471/}} and received a fair amount of interest.

\subsection{Related Work}

\section{Background and Motivation}
\label{sec:motivation}
So far, there has been little literature meant to help cryptography engineers implement correctly Sigma protocols.
Despite Schnorr proofs have been standardized as zero-knowledge proofs (c.f.\ \href{https://tools.ietf.org/html/rfc8235}{RFC8235}) and signatures (c.f.\ ed25519 in \href{https://tools.ietf.org/html/rfc8032}{RFC8032}),
%a
 it is not yet clear what is the correct way to implement a Sigma protocol for a logical statement on the discrete logarithm of a $n$ group elements.
 \minote{reformulate? say something "on the other hand?"}
 For instance, the current standardized ed25519 cannot be trivially adapted to a zero-knowledge proof in a secure way, because of its malleability~\cite[p. 7]{JCEng:BDLSY1},  and the different behavior on the batched and compressed form\footnote{\url{https://hdevalence.ca/blog/2020-10-04-its-25519am}}.
As academic papers focus on proving the security of sigma protocols in generic prime-order groups, the implementation details are often times overlooked in academic papers and, as a result, a lot of insecure implementations have been published in the past. To name a few examples:
\begin{itemize}
\item \textbf{Leakage, partial leakage, or reuse of the nonce is fatal.}
In 2010, the hacker group \texttt{fail0verflow} showed that SONY was reusing the same nonce for digitally signing Playstation 3 games\footnote{\url{https://media.ccc.de/v/27c3-4087-en-console_hacking_2010}}. The member could exploit this to calculate the private key, and create valid signatures.
\minote{this was on ecdsa}
\item \textbf{A weak impelmentation of Fiat--Shamir heuristic compromises adaptive security.} In 2016, Bernhard et al.~\cite{??} demonstrated how Helios, a platform for e-voting, calculated the challenge using the Fiat--Shamir heuristic, without including the generator, allowing for tampering of votes.

\item \textbf{Implementation over non-prime order groups could lead to small subgroup attacks}. In 2017, Monero\footnote{\url{https://www.getmonero.org/2017/05/17/disclosure-of-a-major-bug-in-cryptonote-based-currencies.html}} disclosed a vulnerability in Cryptonote-based e-currencies that would allow double-spending.\href{https://tools.ietf.org/html/rfc2785#ref-LAW}{RFC2785}, that already provides solutions for avoiding small subgroup attacks),
\end{itemize}

\section{Notation and Terminology}

\section{Constructions for $\Sigma$-Protocols}
    \begin{protocol}{Generic flow of a $\Sigma$-protocol\\[-2.25em]}{fig:generic_issuance}{t!}
      \begin{tabular}{@{}l@{\hspace{-2em}}c@{\hspace{-2em}}r@{}}
        $\prover[w,y,R]$ & & $\verifier[y,R]$  \\
        \hline  \\
      % -----------------------------P1-------------------------------
        $ (t,\st) \getsr \prover_1(w,y)$\\
        & $\sendr{t}{100}$ \\[2 ex]
      % -----------------------------CHALLENGE-------------------------------
        & & $c \getsr \CS$ \\
        & $\sendl{c}{100}$ & \\[2 ex]
      % -----------------------------P2-------------------------------
        $ s \getsr \prover_2(w,y,c,\st)$\\
        & $\sendr{s}{100}$ \\[2 ex]
      % -----------------------------V-------------------------------
        & & $\accept/\reject \getsr \verifier(y,t,c,s)$ \\
      \end{tabular}
    \end{protocol}



\subsection{Basic $\Sigma$-Protocols in Prime-Order Groups}
A basic $\Sigma$-protocol for the relation $\relation=\{(y,w) : y=\varphi(w)\}$ for a group homomorphism $\varphi:\GG\to\HH$ is given by the following algorithms:

\begin{enumerate}
  \item
    The prover's first algorithm $\prover_1(w,y)$ consists of the following steps:
    \begin{enumerate}
      \item
        It chooses a random element $r\getsr\GG$.
      \item
        It then computes $t\gets\varphi(r)$.
      \item
	The algorithm sets $\st\gets r$ and outputs $(t,\st)$.
    \end{enumerate}
  \item
    The prover's second algorithm $\prover_2(w,y,c,\st)$ proceeds as follows:
    \begin{enumerate}
      \item
        It checks that $c\in\ZZ_m$ and aborts if this is not the case.
      \item
	It then parses $\st=t$.
      \item
        It computes its output as $s\gets r+cw$.
    \end{enumerate}
  \item
    The verifier's algorithm $\verifier(y,t,c,s)$ proceeds as follow:
    \begin{enumerate}
      \item
        It checks that $s\in\GG$ and $t\in\HH$, and outputs $0$ if this is not the case.
      \item
	It checks whether $t + cy = \varphi(s)$, and outputs $1$ if this is the case; otherwise, $\verifier$ outputs $0$.
    \end{enumerate}
  \item
    The required simulator $\simulator(y,c)$ for a basic $\Sigma$-protocol works as follows:
    \begin{enumerate}
      \item
        It chooses $s\getsr\GG$.
      \item
        It sets $t \gets \varphi(s) - cy$.
      \item
        Finally, the algorithm ouputs the simulated transcript $(t,c,s)$.
    \end{enumerate}
\end{enumerate}


\begin{theorem}
  If $\HH$ is a cyclic group of prime order $q$, $\varphi:\GG\to\HH$ is a group homomorphism, and $m\leq q$, then the above protocol is a $\Sigma$-protocol with simulator $\simulator$.
\end{theorem}

\paragraph{Example 1 (DLOG).}
Let $\HH$ be a group over an elliptic curve with prime order $q$.
Proving knowledge of the discrete logarithm $w$ of a point $Y$ in base $G$ means proving knowledge of $w\in\ZZ_q$ such that $Y=wG$.

Using the above notation, we have $\varphi:\ZZ_q\to\HH:x\mapsto xG$.
The protocol flow is then as follows:
    \begin{protocol}{Proving knowledge of a discrete logarithm\\[-2.25em]}{fig:dlog}{h!}
      \begin{tabular}{@{}l@{\hspace{2em}}c@{\hspace{-3em}}r@{}}
        $\prover[w,Y,G]$ & & $\verifier[Y,G]$  \\
        \hline  \\
      % -----------------------------P1-------------------------------
        $ r\gets\ZZ_q$ & &\\
        $ T = rG$ & & \\
        & $\sendr{T}{100}$ \\[2 ex]
      % -----------------------------CHALLENGE-------------------------------
        & & $c \getsr \ZZ_q$ \\
        & $\sendl{c}{100}$ & \\[2 ex]
      % -----------------------------P2-------------------------------
        $ s \gets r + cw$\\
        & $\sendr{s}{100}$ \\[2 ex]
      % -----------------------------V-------------------------------
        & & Return $1$ if and only if \\
        & & $T + cY = sG$ \\
      \end{tabular}
    \end{protocol}

\paragraph{Example 2 (DLEQ).}
Let $\HH$ be a group over an elliptic curve with prime order $q$.
Proving equality of the known discrete logarithm $w$ of $Y$ in base $G$ and $Z$ in base $H$ means proving knowledge of $w\in\ZZ_q$ such that $Y=wG$ and $Z=wH$.

Using the above notation, we have $\varphi:\ZZ_q\to\HH\times\HH:x\mapsto (xG,xH)$.
The protocol flow is then as follows:
    \begin{protocol}{Proving knowledge of a discrete logarithm\\[-2.25em]}{fig:dlog}{h!}
      \begin{tabular}{@{}l@{\hspace{2em}}c@{\hspace{-3em}}r@{}}
        $\prover[w,Y,G]$ & & $\verifier[Y,G]$  \\
        \hline  \\
      % -----------------------------P1-------------------------------
        $ r\gets\ZZ_q$ & &\\
        $ T = rG$ & & \\
        $ U = rH$ & & \\
        & $\sendr{T,U}{100}$ \\[2 ex]
      % -----------------------------CHALLENGE-------------------------------
        & & $c \getsr \ZZ_q$ \\
        & $\sendl{c}{100}$ & \\[2 ex]
      % -----------------------------P2-------------------------------
        $ s \gets r + cw$\\
        & $\sendr{s}{100}$ \\[2 ex]
      % -----------------------------V-------------------------------
        & & Return $1$ if and only if \\
        & & $T + cY = sG$ \\
        & & and $U + cZ = sH$\\
      \end{tabular}
    \end{protocol}



\subsection{Composition of $\Sigma$-Protocols}
  In this section, we recap composition techniques of $\Sigma$-protocols.
  Specifically, we define mechanisms for proving knowledge of multiple independent witnesses (``AND-composition''), and for proving knowledge for one out of a set of witnesses (``OR-composition'').
  Without loss of generality, the techniques presented in the following focus on the composition of two protocols;
  proving knowledge of more than two witnesses, or for out of a larger set of witnesses, can directly be achieved by iteratively deploying the techniques.

  For the rest of this section, we let $(\prover_1^0,\prover_2^0,\verifier^0)$ and $(\prover_1^1,\prover_2^1,\verifier^1)$ be the specifications of two $\Sigma$-protocols for two relations $\relation^0$ and $\relation^1$, and let $\simulator^0$ and $\simulator^1$ be their simulators.

  Furthermore, we assume that the challenge sets are given by $\ZZ_{m^0}$ and $\ZZ_{m^1}$, respectively.
  We let $m=\min(m^0,m^1)$.


\subsubsection{AND Composition.}
  In the following we explain how to construct a $\Sigma$-protocol proving knowledge of multiple independent witnesses.
  That is, the algorithms specified below constitute a $\Sigma$-protocol for the following relation:
$$
  \relation^\land = \left\{ ((y^0,y^1),(w^0,w^1) : (y^0,w^0)\in \relation^0 ~\land~ (y^1,w^1)\in\relation^1\right\}\,.
$$
  

\begin{enumerate}
  \item
    The prover's first algorithm $\prover_1(w,y)$ consists of the following steps:
    \begin{enumerate}
      \item
        The algorithm parses $w=(w^0,w^1)$ and $y=(y^0,y^1)$.
      \item
        It computes $(t^0,\st^0)\getsr\prover_1^0(y^0,w^0)$ and $(t^1,\st^1)\getsr\prover_1^1(y^1,w^1)$.
      \item
	The algorithm outputs $(t,\st) = ((t^0,t^1),(\st^0,\st^1))$.
    \end{enumerate}
  \item
    The prover's second algorithm $\prover_2(w,y,c,\st)$ proceeds as follows:
    \begin{enumerate}
      \item
        It checks that $c\in\ZZ_m$ and aborts if this is not the case.
      \item
	It parses $\st=(\st^0,\st^1)$
      \item
        It computes $s^0\getsr\prover_2^0(w^0,y^0,c,\st^0)$ and $s^1\getsr\prover_2^1(w^1,y^1,c,\st^1)$.
      \item
        It outputs $s\gets(s^0,s^1)$.
    \end{enumerate}
  \item
    The verifier's algorithm $\verifier(y,t,c,s)$ proceeds as follow:
    \begin{enumerate}
      \item
        It  parses $s=(s^0,s^1)$.
      \item
	The algorithm outputs $\verifier^0(y^0,t^0,c,s^0)\land\verifier^1(y^1,t^1,c,s^1)$.
    \end{enumerate}
  \item
    The required simulator $\simulator(y,c)$ works as follows:
    \begin{enumerate}
      \item
        It parses $y=(y^0,y^1)$.
      \item
        It chooses $c\in\ZZ_m$.
      \item
        It computes $(t^0,c,s^0)\getsr\simulator^0(y^0,c)$ and $(t^1,c,s^1)\getsr\simulator^1(y^1,c)$.
      \item
        Finally, the algorithm then outputs $(t,c,s)=((t^0,t^1),c,(s^0,s^1))$.
    \end{enumerate}
\end{enumerate}

\begin{theorem}
  If, for $i=0,1$, $(\prover_1^i,\prover_2^i,\verifier^i)$ is a $\Sigma$-protocol for relation $\relation^i$ with challenge set $\ZZ_{m^i}$ and simulator $\simulator^i$, then the specified protocol is a $\Sigma$-protocol with challenge set $\ZZ_m$ and simulator $\simulator$ for relation $\relation^\land$.
\end{theorem}


\subsubsection{OR Composition.}
  In the following we explain how to construct a $\Sigma$-protocol proving knowledge of one out of a set of witnesses.
  That is, the algorithms specified below constitute a $\Sigma$-protocol for the following relation:
$$
  \relation^\lor = \left\{ ((y^0,y^1),(w^0,w^1) : (y^0,w^0)\in \relation^0 ~\lor~ (y^1,w^1)\in\relation^1\right\}\,.
$$

  In the following protocol specification, let $j$ be such that $w^j$ is known to the prover, whereas without loss of generality $w^{1-j}$ is assumed to be unknown to the prover.
\begin{enumerate}
  \item
    The prover's first algorithm $\prover_1(w,y)$ consists of the following steps:
    \begin{enumerate}
      \item
        The algorithm parses $w=(w^0,w^1)$ and $y=(y^0,y^1)$, where $w^{1-j}=\bot$.
      \item
        It computes $(t^j,\st^j)\getsr\prover_1^j(y^j,w^j)$.
      \item
        It computes a simulated transcript for the unknown witness by choosing $c^{1-j}\getsr\ZZ_m$ and setting $(t^{1-j},c^{1-j},s^{1-j})\getsr\simulator^{1-j}(y^{1-j},c^{1-j})$.
      \item
	The algorithm outputs $(t,\st) = ((t^0,t^1),(\st^j,c^{1-j},s^{1-j}))$.
    \end{enumerate}
  \item
    The prover's second algorithm $\prover_2(w,y,c,\st)$ proceeds as follows:
    \begin{enumerate}
      \item
        It checks that $c\in\ZZ_m$ and aborts if this is not the case.
      \item
	It parses $\st=(\st^j,c^{1-j},s^{1-j})$.
      \item
        It computes $c^j\gets c-c^{1-j}\mod c^+$, and sets $s^j\getsr\prover_2^j(w^j,y^j,c^j,\st^j)$.
      \item
        It computes $s^0\getsr\prover_2^0(w^0,y^0,c,\st^0)$ and $s^1\getsr\prover_2^1(w^1,y^1,c,\st^1)$.
      \item
        It outputs $s\gets(s^0,s^1,c^0)$.
    \end{enumerate}
  \item
    The verifier's algorithm $\verifier(y,t,c,s)$ proceeds as follow:
    \begin{enumerate}
      \item
        It  parses $s=(s^0,s^1,c^0)$.
      \item 
        It sets $c^1\gets c-c^0\mod c^+$.
      \item
	The algorithm outputs $\verifier^0(y^0,t^0,c^0,s^0)\land\verifier^1(y^1,t^1,c^1,s^1)$.
    \end{enumerate}
  \item
    The required simulator $\simulator(y,c)$ works as follows:
    \begin{enumerate}
      \item
        It parses $y=(y^0,y^1)$.
      \item
        It chooses a random $c^0$ in $\ZZ_m$ and computes $c^1\gets c-c^0 \mod c^+$.
      \item
        It then computes $(t^0,c^0,s^0)\getsr\simulator^0(y^0,c^0)$ and $(t^1,c^1,s^1)\getsr\simulator^1(y^1,c^1)$.
      \item
        Finally, the algorithm then outputs $(t,c,s)=((t^0,t^1),c,(s^0,s^1,c^0))$.
    \end{enumerate}
\end{enumerate}

\begin{theorem}
  If, for $i=0,1$, $(\prover_1^i,\prover_2^i,\verifier^i)$ is a $\Sigma$-protocol for relation $\relation^i$ with challenge set $\ZZ_{m^i}$ and simulator $\simulator^i$, then the specified protocol is a $\Sigma$-protocol with challenge set $\ZZ_m$ and simulator $\simulator$ for relation $\relation^\lor$.
\end{theorem}




\subsection{Achieving Non-Interactivity - The Fiat-Shamir Transform}


\section{Security Considerations}

Papers with the seucurity proofs + limitation
\minote{mention simulation extractability? XXX}
\minote{mention post-quantum security guarantees?}

\section{Implementation}
Implementations already there + APi design + representation + other subleties (check if a point is in the group etc.)

\subsection{Pre-existing implementations}
\paragraph{SCAPI.}
\paragraph{zkp.}
\paragraph{zksk.}
\paragraph{Emmy}

\subsection{A candidate API design}

\paragraph{Key Generation.}

\paragraph{Nonce Generation.} The first stem in the generation of a sigma proof is the generation of a cryptographically secure nonce. As mentioned in \Cref{sec:motivation}, the nonce must be distributed uniformly at random, and even a small bias in the distribution could completely compromise zero-knowledge.
The construction of cryptographically secure source of randomness is a difficult problem, that is particularly challenging on embedded devices such as smart-cards or embedded systems.
For this reason, we propose the generation of a synthetic nonce obtained from hashing the statement and the secret together, as already suggested in previous standards \href{https://tools.ietf.org/html/rfc6979}{RFC6979}.

\minote{XXX. what do we do for ring signatures that repeat the same statement twice? suggest to add a counter or a new random entry in the message?}

\paragraph{Computing the challenge.}

\section{Open Problems}
\minote{check multisignatures and add the new problem of computing proofs with devices that share different keys}
\bibliographystyle{splncs04}
\bibliography{cryptobib/abbrev3,cryptobib/crypto}
%
\end{document}
