% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%



\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{amsthm}
\usepackage{mathtools}
%
\usepackage{todonotes}
%
\usepackage{hyperref}
\usepackage{cleveref}
%
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
\renewcommand\UrlFont{\color{blue}\rmfamily}

\usepackage{todonotes}

\input{macros}

\begin{document}

\title{Proposal: $\Sigma$-protocols%
\thanks{This work has partially been funded by the European Union's Horizon 2020 framework programme under grant agreement no. 830929 (CyberSec4Europe).}}
%
\titlerunning{Proposal: $\Sigma$-protocols}

\author{Stephan Krenn\and
        Michele Orr\`u}

\authorrunning{S. Krenn and M. Orr\`u}

\institute{AIT Austrian Institute of Technology, Vienna, Austria \and
           University of California, Berkeley, United States}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
  We propose a standardization document for sigma protocols in prime order groups, allowing for AND and OR composition, either in compact form (challenge, response) or batchable (commitment, response). We propose a selection of elliptic curves and hash functions suitable for implementations, together with a minimal API that should be consistent across implementations.
  \minote{Add non-interactive}

\keywords{First keyword  \and Second keyword \and Another keyword.}
\end{abstract}

\section{Introduction}

Sigma protocols are simple, mature, and powerful zero-knowledge proof systems.


\subsection{Related Work}

\section{Background and Motivation}
So far, there has been little literature meant to help cryptography engineers implement correctly Sigma protocols.
Despite Schnorr proofs have been standardized as zero-knowledge proofs (c.f.\ \href{https://tools.ietf.org/html/rfc8235}{RFC8235}) and signatures (c.f.\ ed25519 in \href{https://tools.ietf.org/html/rfc8032}{RFC8032}),
%a
 it is not yet clear what is the correct way to implement a Sigma protocol for a logical statement on the discrete logarithm of a $n$ group elements.
 \minote{reformulate? say something "on the other hand?"}
 For instance, the current standardized ed25519 cannot be trivially adapted to a zero-knowledge proof in a secure way, because of its malleability~\cite[p. 7]{JCEng:BDLSY1},  and the different behavior on the batched and compressed form\footnote{\url{https://hdevalence.ca/blog/2020-10-04-its-25519am}}.
The implementation details of sigma protocols are often times overlooked in academic papers and, as a result, a lot of insecure implementations have been published in the past. To name a few examples:
\begin{itemize}
\item \textbf{Leakage, partial leakage, or reuse of the nonce is fatal.}
In 2010, the hacker group \texttt{fail0verflow} showed that SONY was reusing the same nonce for digitally signing Playstation 3 games\footnote{\url{https://media.ccc.de/v/27c3-4087-en-console_hacking_2010}}. The member could exploit this to calculate the private key, and create valid signatures.
\minote{this was on ecdsa}
\item \textbf{A weak impelmentation of Fiat--Shamir heuristic compromises adaptive security.} In 2016, Bernhard et al.~\cite{??} demonstrated how Helios, a platform for e-voting, calculated the challenge using the Fiat--Shamir heuristic, without including the generator, allowing for tampering of votes.

\item \textbf{Implementation over non-prime order groups could lead to small subgroup attacks}. In 2017, Monero\footnote{\url{https://www.getmonero.org/2017/05/17/disclosure-of-a-major-bug-in-cryptonote-based-currencies.html}} disclosed a vulnerability in Cryptonote-based e-currencies that would allow double-spending.\href{https://tools.ietf.org/html/rfc2785#ref-LAW}{RFC2785}, that already provides solutions for avoiding small subgroup attacks),
\end{itemize}

\section{Notation and Terminology}

\section{Constructions for $\Sigma$-Protocols}
    \begin{protocol}{Generic flow of a $\Sigma$-protocol\\[-2.25em]}{fig:generic_issuance}{t!}
      \begin{tabular}{@{}l@{\hspace{-2em}}c@{\hspace{-2em}}r@{}}
        $\prover[w,y,R]$ & & $\verifier[y,R]$  \\
        \hline  \\
      % -----------------------------P1-------------------------------
        $ (t,\st) \getsr \prover_1(w,y)$\\
        & $\sendr{t}{100}$ \\[2 ex]
      % -----------------------------CHALLENGE-------------------------------
        & & $c \getsr \CC$ \\
        & $\sendl{c}{100}$ & \\[2 ex]
      % -----------------------------P2-------------------------------
        $ s \getsr \prover_2(w,y,c,\st)$\\
        & $\sendr{s}{100}$ \\[2 ex]
      % -----------------------------V-------------------------------
        & & $\accept/\reject \getsr \verifier(y,t,c,s)$ \\
      \end{tabular}
    \end{protocol}



\subsection{Basic $\Sigma$-Protocols in Prime-Order Groups}
A basic $\Sigma$-protocol for the relation $\relation=\{(y,w) : y=\varphi(w)\}$ for a group homomorphism $\varphi:\GG\to\HH$ is given by the following algorithms:

\begin{enumerate}
  \item
    The prover's first algorithm $\prover_1$ chooses a random element $r\getsr\GG$ and computes $t\gets\varphi(r)$.
	It sets $\st\gets r$ and sends $t$ to the verifier.
  \item
    Next, the verifier chooses $c\getsr\CC$ and sends $c$ back to the prover.
  \item
    The prover's second algorithm $\prover_2$ checks that $c\in\CC$ and aborts if this is not the case.
	It then parses $\st=t$ and computes its response as $s\gets r+cw$, which it sends to the verifier.
  \item
    The verifier's algorithm $\verifier$ checks that $s\in\GG$ and $t\in\HH$, and outputs $0$ if this is not the case.
	It then checks whether $t + cy = \varphi(s)$, and outputs $1$ if this is the case; otherwise, $\verifier$ outputs $0$.
\end{enumerate}

The required simulator $\simulator$ for a basic $\Sigma$-protocol works as follows:
On input $y$ and a target challenge $c\in\CC$, it chooses $s\getsr\GG$.
It then sets $t \gets \varphi(s) - cy$ and ouputs the simulated transcript $(t,c,s)$.

\begin{theorem}
  If $\HH$ is a cyclic group of prime order $q$, $\varphi:\GG\to\HH$ is a group homomorphism, and $\CC=\ZZ_m$ for some $m\leq q$, then the above $\Sigma$-protocol is an honest-verifier zero-knowledge proof of knowledge for the relation $y=\varphi(w)$.
\end{theorem}

\subsection{Composition of $\Sigma$-Protocols}
\subsubsection{AND Composition.}
  Let $(\prover_1^0,\prover_2^0,\verifier^0)$ and $(\prover_1^1,\prover_2^1,\verifier^1)$ be the specifications of two $\Sigma$-protocols for two relations $\relation^0$ and $\relation^1$, and let $\simulator^0$ and $\simulator^1$ be their simulators.

  The following algorithms then specify a $\Sigma$-protocol for the relation:
$$
  \relation = \left\{ ((y^0,y^1),(w^0,w^1) : (y^0,w^0)\in \relation^0 ~\land~ (y^1,w^1)\in\relation^1\right\}\,.
$$
  
  \begin{enumerate}
    \item
      The prover's first algorithm $\prover_1$ computes $(t^0,\st^0)\getsr\prover_1^0$ and $(t^1,\st^1)\getsr\prover_1^1$.
      It then outputs $(t,\st) = ((t^0,t^1),(\st^0,\st^1))$, and sends $t$ to the verifier.
    \item
      The verifier chooses $c\getsr\CC^0\cap\CC^1$, where $\CC^0$ and $\CC^1$ are the challenge sets of the respective protocols to be composed.
    \item
      In $\prover_2$, the prover parses $\st=(\st^0,\st^1)$.
      It computes $s^0\getsr\prover_2^0(w^0,y^0,c,\st^0)$ and $s^1\getsr\prover_2^1(w^1,y^1,c,\st^1)$.
      The algorithm sets $s\gets(s^0,s^1)$ and sends $s$ to the verifier.
    \item
      The verifier's algorithm $\verifier$ parses $s=(s^0,s^1)$ and outputs $\verifier^0(y^0,t^0,c,s^0)\land\verifier^1(y^1,t^1,c,s^1)$. 
  \end{enumerate}

  The simulator $\simulator$ for the composed protocol works as follows:
  On input $(y^0,y^1)$ and a target challenge $c\in\CC^0\cap\CC^1$, it computes $(t^0,c,s^0)\getsr\simulator^0(y^0,c)$ and $(t^1,c,s^1)\getsr\simulator^1(y^1,c)$.
  The simulator then outputs $(t,c,s)=((t^0,t^1),c,(s^0,s^1))$.

\subsubsection{OR Composition.}
  Let $(\prover_1^0,\prover_2^0,\verifier^0)$ and $(\prover_1^1,\prover_2^1,\verifier^1)$ be the specifications of two $\Sigma$-protocols for two relations $\relation^0$ and $\relation^1$, and let $\simulator^0$ and $\simulator^1$ be their simulators.

  The following algorithms then specify a $\Sigma$-protocol for the relation:
$$
  \relation = \left\{ ((y^0,y^1),(w^0,w^1) : (y^0,w^0)\in \relation^0 ~\lor~ (y^1,w^1)\in\relation^1\right\}\,.
$$

  In the following protocol specification, let $j$ be such that $w^j$ is known to the prover, whereas without loss of generality $w^{1-j}$ is assumed to be unknown to the prover.
  \begin{enumerate}
    \item
      The prover's first algorithm $\prover_1$ computes $(t^j,\st^j)\getsr\prover_1^j$.
      Furthermore, it chooses $c^{1-j}\getsr\CC^0\cap\CC^1$ and computes $(t^{1-j},c^{1-j},s^{1-j})\getsr\simulator^{1-j}(y^{1-j},c^{1-j})$.
      It then ouputs $(t,\st) = ((t^0,t^1),(\st^j,c^{1-j},s^{1-j}))$, and sends $t$ to the verifier.
    \item
      The verifier chooses $c\getsr\CC^0\cap\CC^1$, where $\CC^0$ and $\CC^1$ are the challenge sets of the respective protocols to be composed.
    \item
      In $\prover_2$, the prover parses $\st=(\st^j,c^{1-j},s^{1-j})$.
      It computes $c^j\gets c-c^{1-j}\mod c^+$, and sets $s^j\getsr\prover_2^j(w^j,y^j,c^j,\st^j)$.
      The algorithm sets $s\gets(s^0,s^1,c^0)$ and sends $s$ to the verifier.
    \item
      The verifier's algorithm $\verifier$ parses $s=(s^0,s^1,c^0)$ and computes $c^1\gets c-c^0\mod c^+$.
      It then outputs $\verifier^0(y^0,t^0,c^0,s^0)\land\verifier^1(y^1,t^1,c^1,s^1)$. 
  \end{enumerate}

  The simulator $\simulator$ for the composed protocol works as follows:
  On input $(y^0,y^1)$ and a target challenge $c\in\CC^0\cap\CC^1$, it chooses a random $c^0$ in $\CC^0\cap\CC^1$ and computes $c^1\gets c-c^0 \mod c^+$.
  It then computes $(t^0,c^0,s^0)\getsr\simulator^0(y^0,c^0)$ and $(t^1,c^1,s^1)\getsr\simulator^1(y^1,c^1)$.
  The simulator then outputs $(t,c,s)=((t^0,t^1),c,(s^0,s^1,c^0))$.

\subsection{Achieving Non-Interactivity - The Fiat-Shamir Transform}


\section{Security Considerations}

Papers with the seucurity proofs + limitation
\minote{mention simulation extractability? XXX}

\section{Implementation}
Implementations already there + APi design + representation + other subleties (check if a point is in the group etc.)

\subsection{Pre-existing implementations}
\paragraph{SCAPI.}
\paragraph{zkp.}
\paragraph{zksk.}
\paragraph{Emmy}

\subsection{A candidate API design}

\bibliographystyle{splncs04}
\bibliography{cryptobib/abbrev3,cryptobib/crypto}
%
\end{document}
