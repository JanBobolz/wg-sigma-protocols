% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%



\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{amsthm}
% crypto notation
\usepackage[advantage,
            adversary,
            asymptotics,
            complexity,
            ff,
            lambda,
            mm,
            operators,
            primitives,
            probability,
            sets]{cryptocode}

%
\usepackage{mathtools}
%
\usepackage{todonotes}
%
\usepackage[%dvips,
    pdftex,
    pdftitle={Proposal: Sigma-protocols},
    pdfauthor={Stephan Krenn and Michele Orr√π}, pdfpagelabels=true, %linktocpage=true,     backref=page,
    bookmarks,bookmarksopen,bookmarksdepth=3,
    breaklinks,colorlinks,citecolor=blue,linkcolor=blue
   ]{hyperref}
\usepackage[capitalize,nameinlink,sort]{cleveref}
%
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
\renewcommand\UrlFont{\color{blue}\rmfamily}

\usepackage{todonotes}

\input{macros}

\begin{document}

\title{Proposal: $\Sigma$-protocols%
\thanks{This work has partially been funded by the European Union's Horizon 2020 framework programme under grant agreement no. 830929 (CyberSec4Europe).}}
%
\titlerunning{Proposal: $\Sigma$-protocols}

\author{Stephan Krenn\and
        Michele Orr\`u}

\authorrunning{S. Krenn and M. Orr\`u}

\institute{AIT Austrian Institute of Technology, Vienna, Austria \and
           University of California, Berkeley, United States}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
  We submit a proposal for the standardization of non-interactive sigma protocols in prime order groups, allowing for AND and OR composition, either in compact form (challenge, response) or batchable (commitment, response). We propose a selection of elliptic curves and hash functions suitable for implementations, together with a minimal API that should be consistent across implementations.

%\keywords{First keyword  \and Second keyword \and Another keyword.}
\end{abstract}

\section{Introduction}
Non-intearctive sigma protocols are zero-knowledge~\cite{GolMicRac89} proofs of knowledge~\cite{XX} without SRS, proven secure in the random oracle model.
They have been introduced by Schnorr~\cite{??} and so far have there have been widespread implementations because of their simplicity, maturity, and versatility.
Recently, Lueks et al.~\cite{zksk},

Sigma protocols have already been employed for anonymous credentials, password-authenticated key exchange~\cite{J-PAKE HR08}, (ring, multi)  signatues, and other
cryptographic constructions. Solely in the past XX years, we recall the
\begin{itemize}
  \item DLEQ in some VOPRFs~\cite{cfrg-voprf}, Privacy pass
  \item AND+DLEQ anonymous credentials; (at least) AND+DLEQ: Signal~\cite{CCS:ChaPerZav20}, openings on Pedersen commitments, or plaintexts of ElGamal encryptions; DH tuple: Cryptography for \#metoo~\cite{PoPETS:KuyKraRab19}; Solidus~\cite{CCS:CZJKJS17}; ClaimChain~\cite{ClaimChain}
  \item OR for Ring Signatures: CryptoNote (Monero)~\cite{monero}, Mesh~\cite{MeshPoPETS:AlTGon19};
  \item Signal, who's been using Algebraic MACs~{CCS:ChaMeiZav14}; for group chats;
  \item Coconut~\cite{NDSS:SABMD19} with threshold Issuance Selective Disclosure Credentials with Applications to Distributed Ledgers;
   \item Anonymous Credentials Light
\end{itemize}

A request for standardization has already been posted on the zk-proof community\footnote{\url{https://community.zkproof.org/t/standardizing-sigma-protocols/471/}} and received a fair amount of interest.

\subsection{Related Work}

\section{Background and Motivation}
\label{sec:motivation}
So far, there has been little literature meant to help cryptography engineers implement correctly Sigma protocols for arbitrary statements about discrete logs.
Despite Schnorr signatures and zero-knowledge proofs have already been standardized (respectively in XX and XX), there is no formal, established way to implement sigma protocols and their composition. We stress that this is not straightforward:
%Despite Schnorr proofs have been standardized as zero-knowledge proofs (c.f.\ \href{https://tools.ietf.org/html/rfc8235}{RFC8235}) and signatures (c.f.\ ed25519 in \href{https://tools.ietf.org/html/rfc8032}{RFC8032}),
 for instance, the current standardized ed25519 cannot be immediately adapted to a zero-knowledge proof in a secure way, because of its malleability~\cite[p. 7]{JCEng:BDLSY1},  and the different behavior on the batched and compressed form\footnote{\url{https://hdevalence.ca/blog/2020-10-04-its-25519am}}.
 Additionally, as academic papers focus on proving the security of sigma protocols in generic prime-order groups, the implementation details are often times overlooked, and, as a result, a lot of insecure implementations have been published in the past. To name a few, well-known pitfalls that have led to insecure implementations:
\begin{itemize}

\item \textbf{Implementation over non-prime order groups could lead to small subgroup attacks}. In 2017, Monero\footnote{\url{https://www.getmonero.org/2017/05/17/disclosure-of-a-major-bug-in-cryptonote-based-currencies.html}} disclosed a vulnerability in Cryptonote-based e-currencies that would allow double-spending.\href{https://tools.ietf.org/html/rfc2785#ref-LAW}{RFC2785}, that already provides solutions for avoiding small subgroup attacks)
\item \textbf{Leakage, partial leakage, or reuse of the commitment is fatal.}
In 2010, the hacker group \texttt{fail0verflow} showed that SONY was reusing the same nonce for digitally signing Playstation 3 games\footnote{\url{https://media.ccc.de/v/27c3-4087-en-console_hacking_2010}}. The member could exploit this to calculate the private key, and create valid signatures.
\minote{this was on ecdsa}
\item \textbf{A weak impelmentation of Fiat--Shamir heuristic compromises adaptive security.} In 2016, Bernhard et al.~\cite{??} demonstrated how Helios, a platform for e-voting, calculated the challenge using the Fiat--Shamir heuristic, without including the generator, allowing for tampering of votes.


\end{itemize}

\section{Notation and Terminology}

Following [BFS], we consider a deterministic parameter genration algorithm Pgen that returns a group description $\Gamma \defeq (p, G, \GG)$ of a (cyclic) additive, prime order group $\GG = \langle G \rangle$ of order $p$. With $\secpar$, we denote the security parameter.

\subsection{$\Sigma$-Protocols}
    \begin{protocol}{Generic flow of a $\Sigma$-protocol\\[-2.25em]}{fig:generic}{t!}
      \begin{tabular}{@{}l@{\hspace{-2em}}c@{\hspace{-2em}}r@{}}
        $\prover[w,y,R]$ & & $\verifier[y,R]$  \\
        \hline  \\
      % -----------------------------P1-------------------------------
        $ (t,\st) \getsr \prover_1(w,y)$\\
        & $\sendr{t}{100}$ \\[2 ex]
      % -----------------------------CHALLENGE-------------------------------
        & & $c \getsr \CS$ \\
        & $\sendl{c}{100}$ & \\[2 ex]
      % -----------------------------P2-------------------------------
        $ s \getsr \prover_2(w,y,c,\st)$\\
        & $\sendr{s}{100}$ \\[2 ex]
      % -----------------------------V-------------------------------
        & & $\accept/\reject \getsr \verifier(y,t,c,s)$ \\
      \end{tabular}
    \end{protocol}

    \minote{Put a reference to section 1.4.1 of the community reference document, they'll love it!}
\begin{definition}
  Let $\relation$ be a binary relation and let $(y,w)\in\relation$.
  An interactive two-party protocol specified by algorithms $(\prover_1,\prover_2,\verifier)$ is called a \emph{$\Sigma$-protocol} for $\relation$ with challenge set $\CS$, public input $y$, and private input $w$, if and only if it satisfies the following conditions:
  \begin{description}
    \item[\bf 3-move form:]
      The protocol is of the following form (cf. also Protocol~\ref{fig:generic}):
      \begin{itemize}
        \item
          The prover computes $(t,\st) \getsr \prover_1(w,y)$ and sends $t$ to the verifier, while keeping $\st$ secret.
        \item
          The verifier draws $c\getsr\CS$ and returns it to the prover.
        \item
          The prover computes $s\getsr\prover_2(w,y,c,\st)$ and sends $s$ to the verifier.
        \item
          The verifier accepts the protocol run, if and only if $\verifier(y,t,c,s)=\accept$, otherwise it rejects.
      \end{itemize}
      The protocol transcript $(t,c,s)$ is called \emph{accepting} if the verifier accepts the protocol run.
    \item[\bf Completeness:]
      If $(y,w)\in\relation$, then the verifier always outputs $\accept$.
    \item[\bf Special soundness:]
      There exists an efficient algorithm $\extr$ which, given $y$ and two accepting protocol transcripts $(t,c_1,s_1)$ and $(t,c_2,s_2)$ for public input $y$ with the same first message but different challenges (i.e., $c_1\ne c_2$), returns $w$ such that $(y,w)\in\relation$.
    \item[\bf Special honest-verifier zero-knowledge:]
      There exists an efficient algorithm $\simulator$, which on input $y$ and a challenge $c\in\CS$, outputs transcripts of the form $(t,c,s)$ whose distribution is indinstinguishable from accepting protocol transcripts generated by real protocol runs on public input $y$ and with challenge $c$.
  \end{description}
\end{definition}

\section{Constructions for $\Sigma$-Protocols}
\subsection{Basic $\Sigma$-Protocols in Prime-Order Groups}
A basic $\Sigma$-protocol for the relation $\relation=\{(y,w) : y=\varphi(w)\}$ for a group homomorphism $\varphi:\GG\to\HH$ is given by the following algorithms:

\begin{enumerate}
  \item
    The prover's first algorithm $\prover_1(w,y)$ consists of the following steps:
    \begin{enumerate}
      \item
        It chooses a random element $r\getsr\GG$.
      \item
        It then computes $t\gets\varphi(r)$.
      \item
	The algorithm sets $\st\gets r$ and outputs $(t,\st)$.
    \end{enumerate}
  \item
    The prover's second algorithm $\prover_2(w,y,c,\st)$ proceeds as follows:
    \begin{enumerate}
      \item
        It checks that $c\in\ZZ_m$ and aborts if this is not the case.
      \item
	It then parses $\st=t$.
      \item
        It computes its output as $s\gets r+cw$.
    \end{enumerate}
  \item
    The verifier's algorithm $\verifier(y,t,c,s)$ proceeds as follow:
    \begin{enumerate}
      \item
        It checks that $s\in\GG$ and $t\in\HH$, and outputs $0$ if this is not the case.
      \item
	It checks whether $t + cy = \varphi(s)$, and outputs $1$ if this is the case; otherwise, $\verifier$ outputs $0$.
    \end{enumerate}
  \item
    The required simulator $\simulator(y,c)$ for a basic $\Sigma$-protocol works as follows:
    \begin{enumerate}
      \item
        It chooses $s\getsr\GG$.
      \item
        It sets $t \gets \varphi(s) - cy$.
      \item
        Finally, the algorithm ouputs the simulated transcript $(t,c,s)$.
    \end{enumerate}
\end{enumerate}


\begin{theorem}
  If $\HH$ is a cyclic group of prime order $q$, $\varphi:\GG\to\HH$ is a group homomorphism, and $m\leq q$, then the above protocol is a $\Sigma$-protocol with simulator $\simulator$.
\end{theorem}

\paragraph{Example 1 (DLOG).}
Let $\HH$ be a group over an elliptic curve with prime order $q$.
Proving knowledge of the discrete logarithm $w$ of a point $Y$ in base $G$ means proving knowledge of $w\in\ZZ_q$ such that $Y=wG$.

Using the above notation, we have $\varphi:\ZZ_q\to\HH:x\mapsto xG$.
The protocol flow is then as depicted in Protocol~\ref{fig:dlog}.
    \begin{protocol}{Proving knowledge of a discrete logarithm.\\[-2.25em]}{fig:dlog}{h!}
      \begin{tabular}{@{}l@{\hspace{2em}}c@{\hspace{-3em}}r@{}}
        $\prover[w,Y,G]$ & & $\verifier[Y,G]$  \\
        \hline  \\
      % -----------------------------P1-------------------------------
        $ r\getsr\ZZ_q$ & &\\
        $ T = rG$ & & \\
        & $\sendr{T}{100}$ \\[2 ex]
      % -----------------------------CHALLENGE-------------------------------
        & & $c \getsr \ZZ_q$ \\
        & $\sendl{c}{100}$ & \\[2 ex]
      % -----------------------------P2-------------------------------
        $ s \gets r + cw$\\
        & $\sendr{s}{100}$ \\[2 ex]
      % -----------------------------V-------------------------------
        & & Return $1$ if and only if \\
        & & $T + cY = sG$ \\
      \end{tabular}
    \end{protocol}

For a given challenge $c\in\ZZ_q$, the simulator chooses $s\getsr\ZZ_q$, and sets $T\gets sG-cY$.
It then outputs the simulated transcript $(T,c,s)$.


\paragraph{Example 2 (DLEQ).}
Let $\HH$ be a group over an elliptic curve with prime order $q$.
Proving equality of the known discrete logarithm $w$ of $Y$ in base $G$ and $Z$ in base $H$ means proving knowledge of $w\in\ZZ_q$ such that $Y=wG$ and $Z=wH$.

Using the above notation, we have $\varphi:\ZZ_q\to\HH\times\HH:x\mapsto (xG,xH)$.
The protocol flow is then as depicted in Protocol~\ref{fig:dleq}.
    \begin{protocol}{Proving knowledge of equality of two discrete logarithms.\\[-2.25em]}{fig:dleq}{h!}
      \begin{tabular}{@{}l@{\hspace{2em}}c@{\hspace{-3em}}r@{}}
        $\prover[w,(Y,Z),(G,H)]$ & & $\verifier[(Y,Z),(G,H)]$  \\
        \hline  \\
      % -----------------------------P1-------------------------------
        $ r\getsr\ZZ_q$ & &\\
        $ T = rG$ & & \\
        $ U = rH$ & & \\
        & $\sendr{T,U}{100}$ \\[2 ex]
      % -----------------------------CHALLENGE-------------------------------
        & & $c \getsr \ZZ_q$ \\
        & $\sendl{c}{100}$ & \\[2 ex]
      % -----------------------------P2-------------------------------
        $ s \gets r + cw$\\
        & $\sendr{s}{100}$ \\[2 ex]
      % -----------------------------V-------------------------------
        & & Return $1$ if and only if \\
        & & $T + cY = sG$ \\
        & & and $U + cZ = sH$\\
      \end{tabular}
    \end{protocol}

For a given challenge $c\in\ZZ_q$, the simulator chooses $s\getsr\ZZ_q$, and sets $T\gets sG-cY$ and $U\gets sH - cZ$.
It then outputs the simulated transcript $((T,U),c,s)$.


\paragraph{Example 3 (REP).}
Let $\HH$ be a group over an elliptic curve with prime order $q$.
Proving knowledge of a valid opening of a Pedersen commitment means proving knowledge of $v,w\in\ZZ_q$ such that $Y=vG + wH$.

Using the above notation, we have $\varphi:\ZZ_q\times\ZZ_q\to\HH:(x,y)\mapsto xG + yH$.
The protocol flow is then as depicted in Protocol~\ref{fig:rep}.
    \begin{protocol}{Proving knowledge of representation.\\[-2.25em]}{fig:rep}{h!}
      \begin{tabular}{@{}l@{\hspace{2em}}c@{\hspace{-3em}}r@{}}
        $\prover[(v,w),Y,(G,H)]$ & & $\verifier[Y,(G,H)]$  \\
        \hline  \\
      % -----------------------------P1-------------------------------
        $ r\getsr\ZZ_q$ & &\\
        $ u\getsr\ZZ_q$ & &\\
        $ T = rG + uH$ & & \\
        & $\sendr{T}{100}$ \\[2 ex]
      % -----------------------------CHALLENGE-------------------------------
        & & $c \getsr \ZZ_q$ \\
        & $\sendl{c}{100}$ & \\[2 ex]
      % -----------------------------P2-------------------------------
        $ s \gets r + cv$\\
        $ z \gets u + cw$\\
        & $\sendr{s,z}{100}$ \\[2 ex]
      % -----------------------------V-------------------------------
        & & Return $1$ if and only if \\
        & & $T + cY = sG + zH$ \\
      \end{tabular}
    \end{protocol}

For a given challenge $c\in\ZZ_q$, the simulator chooses $s,z\getsr\ZZ_q$, and sets $T\gets sG + zH -cY$.
It then outputs the simulated transcript $(T,c,(s,z))$.


\subsection{Composition of $\Sigma$-Protocols}
  In this section, we recap composition techniques of $\Sigma$-protocols.
  Specifically, we define mechanisms for proving knowledge of multiple independent witnesses (``AND-composition''), and for proving knowledge for one out of a set of witnesses (``OR-composition'').
  Without loss of generality, the techniques presented in the following focus on the composition of two protocols;
  proving knowledge of more than two witnesses, or for out of a larger set of witnesses, can directly be achieved by iteratively deploying the techniques.

  For the rest of this section, we let $(\prover_1^0,\prover_2^0,\verifier^0)$ and $(\prover_1^1,\prover_2^1,\verifier^1)$ be the specifications of two $\Sigma$-protocols for two relations $\relation^0$ and $\relation^1$, and let $\simulator^0$ and $\simulator^1$ be their simulators.

  Furthermore, we assume that the challenge sets are given by $\ZZ_{m^0}$ and $\ZZ_{m^1}$, respectively.
  We let $m=\min(m^0,m^1)$.


\subsubsection{AND Composition.}
  In the following we explain how to construct a $\Sigma$-protocol proving knowledge of multiple independent witnesses.
  That is, the algorithms specified below constitute a $\Sigma$-protocol for the following relation:
$$
  \relation^\land = \left\{ ((y^0,y^1),(w^0,w^1) : (y^0,w^0)\in \relation^0 ~\land~ (y^1,w^1)\in\relation^1\right\}\,.
$$


\begin{enumerate}
  \item
    The prover's first algorithm $\prover_1(w,y)$ consists of the following steps:
    \begin{enumerate}
      \item
        The algorithm parses $w=(w^0,w^1)$ and $y=(y^0,y^1)$.
      \item
        It computes $(t^0,\st^0)\getsr\prover_1^0(y^0,w^0)$ and $(t^1,\st^1)\getsr\prover_1^1(y^1,w^1)$.
      \item
	The algorithm outputs $(t,\st) = ((t^0,t^1),(\st^0,\st^1))$.
    \end{enumerate}
  \item
    The prover's second algorithm $\prover_2(w,y,c,\st)$ proceeds as follows:
    \begin{enumerate}
      \item
        It checks that $c\in\ZZ_m$ and aborts if this is not the case.
      \item
	It parses $\st=(\st^0,\st^1)$
      \item
        It computes $s^0\getsr\prover_2^0(w^0,y^0,c,\st^0)$ and $s^1\getsr\prover_2^1(w^1,y^1,c,\st^1)$.
      \item
        It outputs $s\gets(s^0,s^1)$.
    \end{enumerate}
  \item
    The verifier's algorithm $\verifier(y,t,c,s)$ proceeds as follow:
    \begin{enumerate}
      \item
        It  parses $s=(s^0,s^1)$.
      \item
	The algorithm outputs $\verifier^0(y^0,t^0,c,s^0)\land\verifier^1(y^1,t^1,c,s^1)$.
    \end{enumerate}
  \item
    The required simulator $\simulator(y,c)$ works as follows:
    \begin{enumerate}
      \item
        It parses $y=(y^0,y^1)$.
      \item
        It chooses $c\in\ZZ_m$.
      \item
        It computes $(t^0,c,s^0)\getsr\simulator^0(y^0,c)$ and $(t^1,c,s^1)\getsr\simulator^1(y^1,c)$.
      \item
        Finally, the algorithm then outputs $(t,c,s)=((t^0,t^1),c,(s^0,s^1))$.
    \end{enumerate}
\end{enumerate}

\begin{theorem}
  If, for $i=0,1$, $(\prover_1^i,\prover_2^i,\verifier^i)$ is a $\Sigma$-protocol for relation $\relation^i$ with challenge set $\ZZ_{m^i}$ and simulator $\simulator^i$, then the specified protocol is a $\Sigma$-protocol with challenge set $\ZZ_m$ and simulator $\simulator$ for relation $\relation^\land$.
\end{theorem}


\subsubsection{OR Composition.}
  In the following we explain how to construct a $\Sigma$-protocol proving knowledge of one out of a set of witnesses.
  That is, the algorithms specified below constitute a $\Sigma$-protocol for the following relation:
$$
  \relation^\lor = \left\{ ((y^0,y^1),(w^0,w^1) : (y^0,w^0)\in \relation^0 ~\lor~ (y^1,w^1)\in\relation^1\right\}\,.
$$

  In the following protocol specification, let $j$ be such that $w^j$ is known to the prover, whereas without loss of generality $w^{1-j}$ is assumed to be unknown to the prover.
\begin{enumerate}
  \item
    The prover's first algorithm $\prover_1(w,y)$ consists of the following steps:
    \begin{enumerate}
      \item
        The algorithm parses $w=(w^0,w^1)$ and $y=(y^0,y^1)$, where $w^{1-j}=\bot$.
      \item
        It computes $(t^j,\st^j)\getsr\prover_1^j(y^j,w^j)$.
      \item
        It computes a simulated transcript for the unknown witness by choosing $c^{1-j}\getsr\ZZ_m$ and setting $(t^{1-j},c^{1-j},s^{1-j})\getsr\simulator^{1-j}(y^{1-j},c^{1-j})$.
      \item
	The algorithm outputs $(t,\st) = ((t^0,t^1),(\st^j,c^{1-j},s^{1-j}))$.
    \end{enumerate}
  \item
    The prover's second algorithm $\prover_2(w,y,c,\st)$ proceeds as follows:
    \begin{enumerate}
      \item
        It checks that $c\in\ZZ_m$ and aborts if this is not the case.
      \item
	It parses $\st=(\st^j,c^{1-j},s^{1-j})$.
      \item
        It computes $c^j\gets c-c^{1-j}\mod m$, and sets $s^j\getsr\prover_2^j(w^j,y^j,c^j,\st^j)$.
      \item
        It computes $s^0\getsr\prover_2^0(w^0,y^0,c,\st^0)$ and $s^1\getsr\prover_2^1(w^1,y^1,c,\st^1)$.
      \item
        It outputs $s\gets(s^0,s^1,c^0)$.
    \end{enumerate}
  \item
    The verifier's algorithm $\verifier(y,t,c,s)$ proceeds as follow:
    \begin{enumerate}
      \item
        It  parses $s=(s^0,s^1,c^0)$.
      \item
        It sets $c^1\gets c-c^0\mod m$.
      \item
	The algorithm outputs $\verifier^0(y^0,t^0,c^0,s^0)\land\verifier^1(y^1,t^1,c^1,s^1)$.
    \end{enumerate}
  \item
    The required simulator $\simulator(y,c)$ works as follows:
    \begin{enumerate}
      \item
        It parses $y=(y^0,y^1)$.
      \item
        It chooses a random $c^0$ in $\ZZ_m$ and computes $c^1\gets c-c^0 \mod m$.
      \item
        It then computes $(t^0,c^0,s^0)\getsr\simulator^0(y^0,c^0)$ and $(t^1,c^1,s^1)\getsr\simulator^1(y^1,c^1)$.
      \item
        Finally, the algorithm then outputs $(t,c,s)=((t^0,t^1),c,(s^0,s^1,c^0))$.
    \end{enumerate}
\end{enumerate}

\begin{theorem}
  If, for $i=0,1$, $(\prover_1^i,\prover_2^i,\verifier^i)$ is a $\Sigma$-protocol for relation $\relation^i$ with challenge set $\ZZ_{m^i}$ and simulator $\simulator^i$, then the specified protocol is a $\Sigma$-protocol with challenge set $\ZZ_m$ and simulator $\simulator$ for relation $\relation^\lor$.
\end{theorem}




\subsection{Achieving Non-Interactivity -- The Fiat-Shamir Transform}

\subsubsection{Long form supporting batch verification.}
\begin{enumerate}
  \item
    The prover's algorithm $\prover'(y,w,\ctx)$ works as follows:
    \begin{enumerate}
      \item
        The algorithm first computes $(t,\st)\getsr\prover_1(y,w)$.
      \item
        It computes the challenge by setting $c\gets\hash(t,y,\ctx)$.
      \item
        The algorithm defines $s\getsr\prover_2(y,w,c,\st)$.
      \item
        The algorithm outputs $(t,s)$.
    \end{enumerate}
  \item
    The verifier's algorithm $\verifier'(y,t,s,\ctx)$ works as follows:
    \begin{enumerate}
      \item
        It recomputes the challenge as $c\gets\hash(t,y,\ctx)$.
      \item
        It outputs whatever $\verifier(y,t,c,s)$ outputs.
    \end{enumerate}
\end{enumerate}

\subsubsection{Short form supporting compact proofs.}
\begin{enumerate}
  \item
    The prover's algorithm $\prover''(y,w,\ctx)$ works as follows:
    \begin{enumerate}
      \item
        The algorithm first computes $(t,\st)\getsr\prover_1(y,w)$.
      \item
        It computes the challenge by setting $c\gets\hash(t,y,\ctx)$.
      \item
        The algorithm defines $s\getsr\prover_2(y,w,c,\st)$.
      \item
        The algorithm outputs $(c,s)$.
    \end{enumerate}
  \item
    The verifier's algorithm $\verifier''(y,c,s,\ctx)$ works as follows:
    \begin{enumerate}
      \item
        The algorithm recomputes the first message $t$ by running the appropriate steps of the simulator $\simulator$.
      \item
        The algorithm checks that $c=\hash(t,y,\ctx)$ and rejects if this is not the case.
      \item
        It outputs whatever $\verifier(y,t,c,s)$ outputs.
    \end{enumerate}
\end{enumerate}

\section{Security Considerations}
Sigma protocols hare honest-verifier zero-knowledge and special sound. The non-interactive variant (that is often discussed in practice) was shown secure by Pointcheval and Stern~\cite{JC:PoiSte00}
Papers with the seucurity proofs + limitation
\minote{mention simulation extractability? XXX}
\minote{mention post-quantum security guarantees?}


\section{Implementation}
Implementations available + selecting the ellptic curves + performance table + proof size.

\subsection{Pre-existing implementations}

supported statement + latest version with date + benchmarks + creation date + citation.
\paragraph{SCAPI.}
\paragraph{zkp.}
\paragraph{zksk.}
\paragraph{Emmy}
\paragraph{Helios}
\subsection{A candidate API design}

\paragraph{Key Generation.}

\paragraph{Nonce Generation.} The first stem in the generation of a sigma proof is the generation of a cryptographically secure nonce. As mentioned in \Cref{sec:motivation}, the nonce must be distributed uniformly at random, and even a small bias in the distribution could completely compromise zero-knowledge.
The construction of cryptographically secure source of randomness is a difficult problem, that is particularly challenging on embedded devices such as smart-cards or embedded systems.
For this reason, we propose the generation of a synthetic nonce obtained from hashing the statement and the secret together, as already suggested in previous standards \href{https://tools.ietf.org/html/rfc6979}{RFC6979}.

\minote{XXX. what do we do for ring signatures that repeat the same statement twice? suggest to add a counter or a new random entry in the message?}

\paragraph{Computing the challenge.} just 128 bits expect post-quantum security + use blake2 or sha256 truncated or sha512 read as an element of $\ZZ_p$


\section{Open Problems}
\minote{check multisignatures and add the new problem of computing proofs with devices that share different keys}
\minote{designated verifier proofs}
\minote{delayed input}
\minote{batching proofs}
\bibliographystyle{splncs04}
\bibliography{cryptobib/abbrev3,cryptobib/crypto}
%
\end{document}
